"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/media-query-parser";
exports.ids = ["vendor-chunks/media-query-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/media-query-parser/dist/media-query-parser.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/media-query-parser/dist/media-query-parser.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   consumeEscape: () => (/* binding */ consumeEscape),\n/* harmony export */   consumeIdent: () => (/* binding */ consumeIdent),\n/* harmony export */   consumeIdentLike: () => (/* binding */ consumeIdentLike),\n/* harmony export */   consumeIdentUnsafe: () => (/* binding */ consumeIdentUnsafe),\n/* harmony export */   consumeNumber: () => (/* binding */ consumeNumber),\n/* harmony export */   consumeNumeric: () => (/* binding */ consumeNumeric),\n/* harmony export */   consumeString: () => (/* binding */ consumeString),\n/* harmony export */   consumeUrl: () => (/* binding */ consumeUrl),\n/* harmony export */   lexicalAnalysis: () => (/* binding */ lexicalAnalysis),\n/* harmony export */   removeWhitespace: () => (/* binding */ removeWhitespace),\n/* harmony export */   syntacticAnalysis: () => (/* binding */ syntacticAnalysis),\n/* harmony export */   toAST: () => (/* binding */ toAST),\n/* harmony export */   toUnflattenedAST: () => (/* binding */ toUnflattenedAST),\n/* harmony export */   tokenizeMediaCondition: () => (/* binding */ tokenizeMediaCondition),\n/* harmony export */   tokenizeMediaFeature: () => (/* binding */ tokenizeMediaFeature),\n/* harmony export */   tokenizeMediaQuery: () => (/* binding */ tokenizeMediaQuery),\n/* harmony export */   tokenizeRange: () => (/* binding */ tokenizeRange),\n/* harmony export */   wouldStartIdentifier: () => (/* binding */ wouldStartIdentifier)\n/* harmony export */ });\n/*! @license MediaQueryParser - MIT License - Tom Golden (github@tbjgolden.com) */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\n\nvar weirdNewlines = /(\\u000D|\\u000C|\\u000D\\u000A)/g;\nvar nullOrSurrogates = /[\\u0000\\uD800-\\uDFFF]/g;\nvar commentRegex = /(\\/\\*)[\\s\\S]*?(\\*\\/)/g;\nvar lexicalAnalysis = function lexicalAnalysis(str, index) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  str = str.replace(weirdNewlines, '\\n').replace(nullOrSurrogates, \"\\uFFFD\");\n  str = str.replace(commentRegex, '');\n  var tokens = [];\n\n  for (; index < str.length; index += 1) {\n    var code = str.charCodeAt(index);\n\n    if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n      var code_1 = str.charCodeAt(++index);\n\n      while (code_1 === 0x0009 || code_1 === 0x0020 || code_1 === 0x000a) {\n        code_1 = str.charCodeAt(++index);\n      }\n\n      index -= 1;\n      tokens.push({\n        type: '<whitespace-token>'\n      });\n    } else if (code === 0x0022) {\n      var result = consumeString(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _a = __read(result, 2),\n          lastIndex = _a[0],\n          value = _a[1];\n\n      tokens.push({\n        type: '<string-token>',\n        value: value\n      });\n      index = lastIndex;\n    } else if (code === 0x0023) {\n      if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index + 1);\n\n        if (nextCode === 0x005f || nextCode >= 0x0041 && nextCode <= 0x005a || nextCode >= 0x0061 && nextCode <= 0x007a || nextCode >= 0x0080 || nextCode >= 0x0030 && nextCode <= 0x0039 || nextCode === 0x005c && index + 2 < str.length && str.charCodeAt(index + 2) !== 0x000a) {\n          var flag = wouldStartIdentifier(str, index + 1) ? 'id' : 'unrestricted';\n          var result = consumeIdentUnsafe(str, index + 1);\n\n          if (result !== null) {\n            var _b = __read(result, 2),\n                lastIndex = _b[0],\n                value = _b[1];\n\n            tokens.push({\n              type: '<hash-token>',\n              value: value.toLowerCase(),\n              flag: flag\n            });\n            index = lastIndex;\n            continue;\n          }\n        }\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x0027) {\n      var result = consumeString(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _c = __read(result, 2),\n          lastIndex = _c[0],\n          value = _c[1];\n\n      tokens.push({\n        type: '<string-token>',\n        value: value\n      });\n      index = lastIndex;\n    } else if (code === 0x0028) {\n      tokens.push({\n        type: '<(-token>'\n      });\n    } else if (code === 0x0029) {\n      tokens.push({\n        type: '<)-token>'\n      });\n    } else if (code === 0x002b) {\n      var plusNumeric = consumeNumeric(str, index);\n\n      if (plusNumeric === null) {\n        tokens.push({\n          type: '<delim-token>',\n          value: code\n        });\n      } else {\n        var _d = __read(plusNumeric, 2),\n            lastIndex = _d[0],\n            tokenTuple = _d[1];\n\n        if (tokenTuple[0] === '<dimension-token>') {\n          tokens.push({\n            type: '<dimension-token>',\n            value: tokenTuple[1],\n            unit: tokenTuple[2].toLowerCase(),\n            flag: 'number'\n          });\n        } else if (tokenTuple[0] === '<number-token>') {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: tokenTuple[2]\n          });\n        } else {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: 'number'\n          });\n        }\n\n        index = lastIndex;\n      }\n    } else if (code === 0x002c) {\n      tokens.push({\n        type: '<comma-token>'\n      });\n    } else if (code === 0x002d) {\n      var minusNumeric = consumeNumeric(str, index);\n\n      if (minusNumeric !== null) {\n        var _e = __read(minusNumeric, 2),\n            lastIndex = _e[0],\n            tokenTuple = _e[1];\n\n        if (tokenTuple[0] === '<dimension-token>') {\n          tokens.push({\n            type: '<dimension-token>',\n            value: tokenTuple[1],\n            unit: tokenTuple[2].toLowerCase(),\n            flag: 'number'\n          });\n        } else if (tokenTuple[0] === '<number-token>') {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: tokenTuple[2]\n          });\n        } else {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: 'number'\n          });\n        }\n\n        index = lastIndex;\n        continue;\n      }\n\n      if (index + 2 < str.length) {\n        var nextCode = str.charCodeAt(index + 1);\n        var nextNextCode = str.charCodeAt(index + 2);\n\n        if (nextCode === 0x002d && nextNextCode === 0x003e) {\n          tokens.push({\n            type: '<CDC-token>'\n          });\n          index += 2;\n          continue;\n        }\n      }\n\n      var result = consumeIdentLike(str, index);\n\n      if (result !== null) {\n        var _f = __read(result, 3),\n            lastIndex = _f[0],\n            value = _f[1],\n            type = _f[2];\n\n        tokens.push({\n          type: type,\n          value: value\n        });\n        index = lastIndex;\n        continue;\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x002e) {\n      var minusNumeric = consumeNumeric(str, index);\n\n      if (minusNumeric === null) {\n        tokens.push({\n          type: '<delim-token>',\n          value: code\n        });\n      } else {\n        var _g = __read(minusNumeric, 2),\n            lastIndex = _g[0],\n            tokenTuple = _g[1];\n\n        if (tokenTuple[0] === '<dimension-token>') {\n          tokens.push({\n            type: '<dimension-token>',\n            value: tokenTuple[1],\n            unit: tokenTuple[2].toLowerCase(),\n            flag: 'number'\n          });\n        } else if (tokenTuple[0] === '<number-token>') {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: tokenTuple[2]\n          });\n        } else {\n          tokens.push({\n            type: tokenTuple[0],\n            value: tokenTuple[1],\n            flag: 'number'\n          });\n        }\n\n        index = lastIndex;\n        continue;\n      }\n    } else if (code === 0x003a) {\n      tokens.push({\n        type: '<colon-token>'\n      });\n    } else if (code === 0x003b) {\n      tokens.push({\n        type: '<semicolon-token>'\n      });\n    } else if (code === 0x003c) {\n      if (index + 3 < str.length) {\n        var nextCode = str.charCodeAt(index + 1);\n        var nextNextCode = str.charCodeAt(index + 2);\n        var nextNextNextCode = str.charCodeAt(index + 3);\n\n        if (nextCode === 0x0021 && nextNextCode === 0x002d && nextNextNextCode === 0x002d) {\n          tokens.push({\n            type: '<CDO-token>'\n          });\n          index += 3;\n          continue;\n        }\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x0040) {\n      var result = consumeIdent(str, index + 1);\n\n      if (result !== null) {\n        var _h = __read(result, 2),\n            lastIndex = _h[0],\n            value = _h[1];\n\n        tokens.push({\n          type: '<at-keyword-token>',\n          value: value.toLowerCase()\n        });\n        index = lastIndex;\n        continue;\n      }\n\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    } else if (code === 0x005b) {\n      tokens.push({\n        type: '<[-token>'\n      });\n    } else if (code === 0x005c) {\n      var result = consumeEscape(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _j = __read(result, 2),\n          lastIndex = _j[0],\n          value = _j[1];\n\n      str = str.slice(0, index) + value + str.slice(lastIndex + 1);\n      index -= 1;\n    } else if (code === 0x005d) {\n      tokens.push({\n        type: '<]-token>'\n      });\n    } else if (code === 0x007b) {\n      tokens.push({\n        type: '<{-token>'\n      });\n    } else if (code === 0x007d) {\n      tokens.push({\n        type: '<}-token>'\n      });\n    } else if (code >= 0x0030 && code <= 0x0039) {\n      var result = consumeNumeric(str, index);\n\n      var _k = __read(result, 2),\n          lastIndex = _k[0],\n          tokenTuple = _k[1];\n\n      if (tokenTuple[0] === '<dimension-token>') {\n        tokens.push({\n          type: '<dimension-token>',\n          value: tokenTuple[1],\n          unit: tokenTuple[2].toLowerCase(),\n          flag: 'number'\n        });\n      } else if (tokenTuple[0] === '<number-token>') {\n        tokens.push({\n          type: tokenTuple[0],\n          value: tokenTuple[1],\n          flag: tokenTuple[2]\n        });\n      } else {\n        tokens.push({\n          type: tokenTuple[0],\n          value: tokenTuple[1],\n          flag: 'number'\n        });\n      }\n\n      index = lastIndex;\n    } else if (code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080) {\n      var result = consumeIdentLike(str, index);\n\n      if (result === null) {\n        return null;\n      }\n\n      var _l = __read(result, 3),\n          lastIndex = _l[0],\n          value = _l[1],\n          type = _l[2];\n\n      tokens.push({\n        type: type,\n        value: value\n      });\n      index = lastIndex;\n    } else {\n      tokens.push({\n        type: '<delim-token>',\n        value: code\n      });\n    }\n  }\n\n  tokens.push({\n    type: '<EOF-token>'\n  });\n  return tokens;\n};\nvar consumeString = function consumeString(str, index) {\n  if (str.length <= index + 1) return null;\n  var firstCode = str.charCodeAt(index);\n  var charCodes = [];\n\n  for (var i = index + 1; i < str.length; i += 1) {\n    var code = str.charCodeAt(i);\n\n    if (code === firstCode) {\n      return [i, String.fromCharCode.apply(null, charCodes)];\n    } else if (code === 0x005c) {\n      var result = consumeEscape(str, i);\n      if (result === null) return null;\n\n      var _a = __read(result, 2),\n          lastIndex = _a[0],\n          charCode = _a[1];\n\n      charCodes.push(charCode);\n      i = lastIndex;\n    } else if (code === 0x000a) {\n      return null;\n    } else {\n      charCodes.push(code);\n    }\n  }\n\n  return null;\n};\nvar wouldStartIdentifier = function wouldStartIdentifier(str, index) {\n  if (str.length <= index) return false;\n  var code = str.charCodeAt(index);\n\n  if (code === 0x002d) {\n    if (str.length <= index + 1) return false;\n    var nextCode = str.charCodeAt(index + 1);\n\n    if (nextCode === 0x002d || nextCode === 0x005f || nextCode >= 0x0041 && nextCode <= 0x005a || nextCode >= 0x0061 && nextCode <= 0x007a || nextCode >= 0x0080) {\n      return true;\n    } else if (nextCode === 0x005c) {\n      if (str.length <= index + 2) return false;\n      var nextNextCode = str.charCodeAt(index + 2);\n      return nextNextCode !== 0x000a;\n    } else {\n      return false;\n    }\n  } else if (code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080) {\n    return true;\n  } else if (code === 0x005c) {\n    if (str.length <= index + 1) return false;\n    var nextCode = str.charCodeAt(index + 1);\n    return nextCode !== 0x000a;\n  } else {\n    return false;\n  }\n};\nvar consumeEscape = function consumeEscape(str, index) {\n  if (str.length <= index + 1) return null;\n  if (str.charCodeAt(index) !== 0x005c) return null;\n  var code = str.charCodeAt(index + 1);\n\n  if (code === 0x000a) {\n    return null;\n  } else if (code >= 0x0030 && code <= 0x0039 || code >= 0x0041 && code <= 0x0046 || code >= 0x0061 && code <= 0x0066) {\n    var hexCharCodes = [code];\n    var min = Math.min(index + 7, str.length);\n    var i = index + 2;\n\n    for (; i < min; i += 1) {\n      var code_2 = str.charCodeAt(i);\n\n      if (code_2 >= 0x0030 && code_2 <= 0x0039 || code_2 >= 0x0041 && code_2 <= 0x0046 || code_2 >= 0x0061 && code_2 <= 0x0066) {\n        hexCharCodes.push(code_2);\n      } else {\n        break;\n      }\n    }\n\n    if (i < str.length) {\n      var code_3 = str.charCodeAt(i);\n\n      if (code_3 === 0x0009 || code_3 === 0x0020 || code_3 === 0x000a) {\n        i += 1;\n      }\n    }\n\n    return [i - 1, parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)];\n  } else {\n    return [index + 1, code];\n  }\n};\nvar consumeNumeric = function consumeNumeric(str, index) {\n  var numberResult = consumeNumber(str, index);\n  if (numberResult === null) return null;\n\n  var _a = __read(numberResult, 3),\n      numberEndIndex = _a[0],\n      numberValue = _a[1],\n      numberFlag = _a[2];\n\n  var identResult = consumeIdent(str, numberEndIndex + 1);\n\n  if (identResult !== null) {\n    var _b = __read(identResult, 2),\n        identEndIndex = _b[0],\n        identValue = _b[1];\n\n    return [identEndIndex, ['<dimension-token>', numberValue, identValue]];\n  }\n\n  if (numberEndIndex + 1 < str.length && str.charCodeAt(numberEndIndex + 1) === 0x0025) {\n    return [numberEndIndex + 1, ['<percentage-token>', numberValue]];\n  }\n\n  return [numberEndIndex, ['<number-token>', numberValue, numberFlag]];\n};\nvar consumeNumber = function consumeNumber(str, index) {\n  if (str.length <= index) return null;\n  var flag = 'integer';\n  var numberChars = [];\n  var firstCode = str.charCodeAt(index);\n\n  if (firstCode === 0x002b || firstCode === 0x002d) {\n    index += 1;\n    if (firstCode === 0x002d) numberChars.push(0x002d);\n  }\n\n  while (index < str.length) {\n    var code = str.charCodeAt(index);\n\n    if (code >= 0x0030 && code <= 0x0039) {\n      numberChars.push(code);\n      index += 1;\n    } else {\n      break;\n    }\n  }\n\n  if (index + 1 < str.length) {\n    var nextCode = str.charCodeAt(index);\n    var nextNextCode = str.charCodeAt(index + 1);\n\n    if (nextCode === 0x002e && nextNextCode >= 0x0030 && nextNextCode <= 0x0039) {\n      numberChars.push(nextCode, nextNextCode);\n      flag = 'number';\n      index += 2;\n\n      while (index < str.length) {\n        var code = str.charCodeAt(index);\n\n        if (code >= 0x0030 && code <= 0x0039) {\n          numberChars.push(code);\n          index += 1;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n\n  if (index + 1 < str.length) {\n    var nextCode = str.charCodeAt(index);\n    var nextNextCode = str.charCodeAt(index + 1);\n    var nextNextNextCode = str.charCodeAt(index + 2);\n\n    if (nextCode === 0x0045 || nextCode === 0x0065) {\n      var nextNextIsDigit = nextNextCode >= 0x0030 && nextNextCode <= 0x0039;\n\n      if (nextNextIsDigit || (nextNextCode === 0x002b || nextNextCode === 0x002d) && nextNextNextCode >= 0x0030 && nextNextNextCode <= 0x0039) {\n        flag = 'number';\n\n        if (nextNextIsDigit) {\n          numberChars.push(0x0045, nextNextCode);\n          index += 2;\n        } else if (nextNextCode === 0x002d) {\n          numberChars.push(0x0045, 0x002d, nextNextNextCode);\n          index += 3;\n        } else {\n          numberChars.push(0x0045, nextNextNextCode);\n          index += 3;\n        }\n\n        while (index < str.length) {\n          var code = str.charCodeAt(index);\n\n          if (code >= 0x0030 && code <= 0x0039) {\n            numberChars.push(code);\n            index += 1;\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  var numberString = String.fromCharCode.apply(null, numberChars);\n  var value = flag === 'number' ? parseFloat(numberString) : parseInt(numberString);\n  if (value === -0) value = 0;\n  return Number.isNaN(value) ? null : [index - 1, value, flag];\n};\nvar consumeIdentUnsafe = function consumeIdentUnsafe(str, index) {\n  if (str.length <= index) {\n    return null;\n  }\n\n  var identChars = [];\n\n  for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {\n    if (code === 0x002d || code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080 || code >= 0x0030 && code <= 0x0039) {\n      identChars.push(code);\n      continue;\n    } else {\n      var result = consumeEscape(str, index);\n\n      if (result !== null) {\n        var _a = __read(result, 2),\n            lastIndex = _a[0],\n            code_4 = _a[1];\n\n        identChars.push(code_4);\n        index = lastIndex;\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  return index === 0 ? null : [index - 1, String.fromCharCode.apply(null, identChars)];\n};\nvar consumeIdent = function consumeIdent(str, index) {\n  if (str.length <= index || !wouldStartIdentifier(str, index)) {\n    return null;\n  }\n\n  var identChars = [];\n\n  for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {\n    if (code === 0x002d || code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080 || code >= 0x0030 && code <= 0x0039) {\n      identChars.push(code);\n      continue;\n    } else {\n      var result = consumeEscape(str, index);\n\n      if (result !== null) {\n        var _a = __read(result, 2),\n            lastIndex = _a[0],\n            code_5 = _a[1];\n\n        identChars.push(code_5);\n        index = lastIndex;\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  return [index - 1, String.fromCharCode.apply(null, identChars)];\n};\nvar consumeUrl = function consumeUrl(str, index) {\n  var code = str.charCodeAt(index);\n\n  while (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n    code = str.charCodeAt(++index);\n  }\n\n  var urlChars = [];\n  var hasFinishedWord = false;\n\n  while (index < str.length) {\n    if (code === 0x0029) {\n      return [index, String.fromCharCode.apply(null, urlChars)];\n    } else if (code === 0x0022 || code === 0x0027 || code === 0x0028) {\n      return null;\n    } else if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n      if (!hasFinishedWord && urlChars.length !== 0) hasFinishedWord = true;\n    } else if (code === 0x005c) {\n      var result = consumeEscape(str, index);\n      if (result === null || hasFinishedWord) return null;\n\n      var _a = __read(result, 2),\n          lastIndex = _a[0],\n          value = _a[1];\n\n      urlChars.push(value);\n      index = lastIndex;\n    } else {\n      if (hasFinishedWord) return null;\n      urlChars.push(code);\n    }\n\n    code = str.charCodeAt(++index);\n  }\n\n  return null;\n};\nvar consumeIdentLike = function consumeIdentLike(str, index) {\n  var result = consumeIdent(str, index);\n  if (result === null) return null;\n\n  var _a = __read(result, 2),\n      lastIndex = _a[0],\n      value = _a[1];\n\n  if (value.toLowerCase() === 'url') {\n    if (str.length > lastIndex + 1) {\n      var nextCode = str.charCodeAt(lastIndex + 1);\n\n      if (nextCode === 0x0028) {\n        for (var offset = 2; lastIndex + offset < str.length; offset += 1) {\n          var nextNextCode = str.charCodeAt(lastIndex + offset);\n\n          if (nextNextCode === 0x0022 || nextNextCode === 0x0027) {\n            return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n          } else if (nextNextCode !== 0x0009 && nextNextCode !== 0x0020 && nextNextCode !== 0x000a) {\n            var result_1 = consumeUrl(str, lastIndex + offset);\n            if (result_1 === null) return null;\n\n            var _b = __read(result_1, 2),\n                lastUrlIndex = _b[0],\n                value_1 = _b[1];\n\n            return [lastUrlIndex, value_1, '<url-token>'];\n          }\n        }\n\n        return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n      }\n    }\n  } else if (str.length > lastIndex + 1) {\n    var nextCode = str.charCodeAt(lastIndex + 1);\n\n    if (nextCode === 0x0028) {\n      return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n    }\n  }\n\n  return [lastIndex, value.toLowerCase(), '<ident-token>'];\n};\n\nvar simplifyAST = function simplifyAST(ast) {\n  for (var i = ast.length - 1; i >= 0; i--) {\n    ast[i] = simplifyMediaQuery(ast[i]);\n  }\n\n  return ast;\n};\n\nvar simplifyMediaQuery = function simplifyMediaQuery(mediaQuery) {\n  if (mediaQuery.mediaCondition === null) return mediaQuery;\n  var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);\n\n  if (mediaCondition.operator === null && mediaCondition.children.length === 1 && 'children' in mediaCondition.children[0]) {\n    mediaCondition = mediaCondition.children[0];\n  }\n\n  return {\n    mediaPrefix: mediaQuery.mediaPrefix,\n    mediaType: mediaQuery.mediaType,\n    mediaCondition: mediaCondition\n  };\n};\n\nvar simplifyMediaCondition = function simplifyMediaCondition(mediaCondition) {\n  for (var i = mediaCondition.children.length - 1; i >= 0; i--) {\n    var unsimplifiedChild = mediaCondition.children[i];\n\n    if (!('context' in unsimplifiedChild)) {\n      var child = simplifyMediaCondition(unsimplifiedChild);\n\n      if (child.operator === null && child.children.length === 1) {\n        mediaCondition.children[i] = child.children[0];\n      } else if (child.operator === mediaCondition.operator && (child.operator === 'and' || child.operator === 'or')) {\n        var spliceArgs = [i, 1];\n\n        for (var i_1 = 0; i_1 < child.children.length; i_1++) {\n          spliceArgs.push(child.children[i_1]);\n        }\n\n        mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);\n      }\n    }\n  }\n\n  return mediaCondition;\n};\n\nvar createError = function createError(message, err) {\n  if (err instanceof Error) {\n    return new Error(\"\".concat(err.message.trim(), \"\\n\").concat(message.trim()));\n  } else {\n    return new Error(message.trim());\n  }\n};\n\nvar toAST = function toAST(str) {\n  return simplifyAST(toUnflattenedAST(str));\n};\nvar toUnflattenedAST = function toUnflattenedAST(str) {\n  var tokenList = lexicalAnalysis(str.trim());\n\n  if (tokenList === null) {\n    throw createError('Failed tokenizing');\n  }\n\n  var startIndex = 0;\n  var endIndex = tokenList.length - 1;\n\n  if (tokenList[0].type === '<at-keyword-token>' && tokenList[0].value === 'media') {\n    if (tokenList[1].type !== '<whitespace-token>') {\n      throw createError('Expected whitespace after media');\n    }\n\n    startIndex = 2;\n\n    for (var i = 2; i < tokenList.length - 1; i++) {\n      var token = tokenList[i];\n\n      if (token.type === '<{-token>') {\n        endIndex = i;\n        break;\n      } else if (token.type === '<semicolon-token>') {\n        throw createError(\"Expected '{' in media query but found ';'\");\n      }\n    }\n  }\n\n  tokenList = tokenList.slice(startIndex, endIndex);\n  return syntacticAnalysis(tokenList);\n};\nvar removeWhitespace = function removeWhitespace(tokenList) {\n  var newTokenList = [];\n  var before = false;\n\n  for (var i = 0; i < tokenList.length; i++) {\n    if (tokenList[i].type === '<whitespace-token>') {\n      before = true;\n\n      if (newTokenList.length > 0) {\n        newTokenList[newTokenList.length - 1].wsAfter = true;\n      }\n    } else {\n      newTokenList.push(__assign(__assign({}, tokenList[i]), {\n        wsBefore: before,\n        wsAfter: false\n      }));\n      before = false;\n    }\n  }\n\n  return newTokenList;\n};\nvar syntacticAnalysis = function syntacticAnalysis(tokenList) {\n  var e_1, _a;\n\n  var mediaQueryList = [[]];\n\n  for (var i = 0; i < tokenList.length; i++) {\n    var token = tokenList[i];\n\n    if (token.type === '<comma-token>') {\n      mediaQueryList.push([]);\n    } else {\n      mediaQueryList[mediaQueryList.length - 1].push(token);\n    }\n  }\n\n  var mediaQueries = mediaQueryList.map(removeWhitespace);\n\n  if (mediaQueries.length === 1 && mediaQueries[0].length === 0) {\n    return [{\n      mediaCondition: null,\n      mediaPrefix: null,\n      mediaType: 'all'\n    }];\n  } else {\n    var mediaQueryTokens = mediaQueries.map(function (mediaQueryTokens) {\n      if (mediaQueryTokens.length === 0) {\n        return null;\n      } else {\n        return tokenizeMediaQuery(mediaQueryTokens);\n      }\n    });\n    var nonNullMediaQueryTokens = [];\n\n    try {\n      for (var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()) {\n        var mediaQueryToken = mediaQueryTokens_1_1.value;\n\n        if (mediaQueryToken !== null) {\n          nonNullMediaQueryTokens.push(mediaQueryToken);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a = mediaQueryTokens_1[\"return\"])) _a.call(mediaQueryTokens_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (nonNullMediaQueryTokens.length === 0) {\n      throw createError('No valid media queries');\n    }\n\n    return nonNullMediaQueryTokens;\n  }\n};\nvar tokenizeMediaQuery = function tokenizeMediaQuery(tokens) {\n  var firstToken = tokens[0];\n\n  if (firstToken.type === '<(-token>') {\n    try {\n      return {\n        mediaPrefix: null,\n        mediaType: 'all',\n        mediaCondition: tokenizeMediaCondition(tokens, true)\n      };\n    } catch (err) {\n      throw createError(\"Expected media condition after '('\", err);\n    }\n  } else if (firstToken.type === '<ident-token>') {\n    var mediaPrefix = null;\n    var mediaType = void 0;\n    var value = firstToken.value;\n\n    if (value === 'only' || value === 'not') {\n      mediaPrefix = value;\n    }\n\n    var firstIndex = mediaPrefix === null ? 0 : 1;\n\n    if (tokens.length <= firstIndex) {\n      throw createError(\"Expected extra token in media query\");\n    }\n\n    var firstNonUnaryToken = tokens[firstIndex];\n\n    if (firstNonUnaryToken.type === '<ident-token>') {\n      var value_1 = firstNonUnaryToken.value;\n\n      if (value_1 === 'all') {\n        mediaType = 'all';\n      } else if (value_1 === 'print' || value_1 === 'screen') {\n        mediaType = value_1;\n      } else if (value_1 === 'tty' || value_1 === 'tv' || value_1 === 'projection' || value_1 === 'handheld' || value_1 === 'braille' || value_1 === 'embossed' || value_1 === 'aural' || value_1 === 'speech') {\n        mediaPrefix = mediaPrefix === 'not' ? null : 'not';\n        mediaType = 'all';\n      } else {\n        throw createError(\"Unknown ident '\".concat(value_1, \"' in media query\"));\n      }\n    } else if (mediaPrefix === 'not' && firstNonUnaryToken.type === '<(-token>') {\n      var tokensWithParens = [{\n        type: '<(-token>',\n        wsBefore: false,\n        wsAfter: false\n      }];\n      tokensWithParens.push.apply(tokensWithParens, tokens);\n      tokensWithParens.push({\n        type: '<)-token>',\n        wsBefore: false,\n        wsAfter: false\n      });\n\n      try {\n        return {\n          mediaPrefix: null,\n          mediaType: 'all',\n          mediaCondition: tokenizeMediaCondition(tokensWithParens, true)\n        };\n      } catch (err) {\n        throw createError(\"Expected media condition after '('\", err);\n      }\n    } else {\n      throw createError('Invalid media query');\n    }\n\n    if (firstIndex + 1 === tokens.length) {\n      return {\n        mediaPrefix: mediaPrefix,\n        mediaType: mediaType,\n        mediaCondition: null\n      };\n    } else if (firstIndex + 4 < tokens.length) {\n      var secondNonUnaryToken = tokens[firstIndex + 1];\n\n      if (secondNonUnaryToken.type === '<ident-token>' && secondNonUnaryToken.value === 'and') {\n        try {\n          return {\n            mediaPrefix: mediaPrefix,\n            mediaType: mediaType,\n            mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), false)\n          };\n        } catch (err) {\n          throw createError(\"Expected media condition after 'and'\", err);\n        }\n      } else {\n        throw createError(\"Expected 'and' after media prefix\");\n      }\n    } else {\n      throw createError('Expected media condition after media prefix');\n    }\n  } else {\n    throw createError('Expected media condition or media prefix');\n  }\n};\nvar tokenizeMediaCondition = function tokenizeMediaCondition(tokens, mayContainOr, previousOperator) {\n  if (previousOperator === void 0) {\n    previousOperator = null;\n  }\n\n  if (tokens.length < 3 || tokens[0].type !== '<(-token>' || tokens[tokens.length - 1].type !== '<)-token>') {\n    throw new Error('Invalid media condition');\n  }\n\n  var endIndexOfFirstFeature = tokens.length - 1;\n  var maxDepth = 0;\n  var count = 0;\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (token.type === '<(-token>') {\n      count += 1;\n      maxDepth = Math.max(maxDepth, count);\n    } else if (token.type === '<)-token>') {\n      count -= 1;\n    }\n\n    if (count === 0) {\n      endIndexOfFirstFeature = i;\n      break;\n    }\n  }\n\n  if (count !== 0) {\n    throw new Error('Mismatched parens\\nInvalid media condition');\n  }\n\n  var child;\n  var featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);\n\n  if (maxDepth === 1) {\n    child = tokenizeMediaFeature(featureTokens);\n  } else {\n    if (featureTokens[1].type === '<ident-token>' && featureTokens[1].value === 'not') {\n      child = tokenizeMediaCondition(featureTokens.slice(2, -1), true, 'not');\n    } else {\n      child = tokenizeMediaCondition(featureTokens.slice(1, -1), true);\n    }\n  }\n\n  if (endIndexOfFirstFeature === tokens.length - 1) {\n    return {\n      operator: previousOperator,\n      children: [child]\n    };\n  } else {\n    var nextToken = tokens[endIndexOfFirstFeature + 1];\n\n    if (nextToken.type !== '<ident-token>') {\n      throw new Error('Invalid operator\\nInvalid media condition');\n    } else if (previousOperator !== null && previousOperator !== nextToken.value) {\n      throw new Error(\"'\".concat(nextToken.value, \"' and '\").concat(previousOperator, \"' must not be at same level\\nInvalid media condition\"));\n    } else if (nextToken.value === 'or' && !mayContainOr) {\n      throw new Error(\"Cannot use 'or' at top level of a media query\\nInvalid media condition\");\n    } else if (nextToken.value !== 'and' && nextToken.value !== 'or') {\n      throw new Error(\"Invalid operator: '\".concat(nextToken.value, \"'\\nInvalid media condition\"));\n    }\n\n    var siblings = tokenizeMediaCondition(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);\n    return {\n      operator: nextToken.value,\n      children: [child].concat(siblings.children)\n    };\n  }\n};\nvar tokenizeMediaFeature = function tokenizeMediaFeature(rawTokens) {\n  if (rawTokens.length < 3 || rawTokens[0].type !== '<(-token>' || rawTokens[rawTokens.length - 1].type !== '<)-token>') {\n    throw new Error('Invalid media feature');\n  }\n\n  var tokens = [rawTokens[0]];\n\n  for (var i = 1; i < rawTokens.length; i++) {\n    if (i < rawTokens.length - 2) {\n      var a = rawTokens[i];\n      var b = rawTokens[i + 1];\n      var c = rawTokens[i + 2];\n\n      if (a.type === '<number-token>' && a.value > 0 && b.type === '<delim-token>' && b.value === 0x002f && c.type === '<number-token>' && c.value > 0) {\n        tokens.push({\n          type: '<ratio-token>',\n          numerator: a.value,\n          denominator: c.value,\n          wsBefore: a.wsBefore,\n          wsAfter: c.wsAfter\n        });\n        i += 2;\n        continue;\n      }\n    }\n\n    tokens.push(rawTokens[i]);\n  }\n\n  var nextToken = tokens[1];\n\n  if (nextToken.type === '<ident-token>' && tokens.length === 3) {\n    return {\n      context: 'boolean',\n      feature: nextToken.value\n    };\n  } else if (tokens.length === 5 && tokens[1].type === '<ident-token>' && tokens[2].type === '<colon-token>') {\n    var valueToken = tokens[3];\n\n    if (valueToken.type === '<number-token>' || valueToken.type === '<dimension-token>' || valueToken.type === '<ratio-token>' || valueToken.type === '<ident-token>') {\n      var feature = tokens[1].value;\n      var prefix = null;\n      var slice = feature.slice(0, 4);\n\n      if (slice === 'min-') {\n        prefix = 'min';\n        feature = feature.slice(4);\n      } else if (slice === 'max-') {\n        prefix = 'max';\n        feature = feature.slice(4);\n      }\n\n      valueToken.wsBefore;\n          valueToken.wsAfter;\n          var value = __rest(valueToken, [\"wsBefore\", \"wsAfter\"]);\n\n      return {\n        context: 'value',\n        prefix: prefix,\n        feature: feature,\n        value: value\n      };\n    }\n  } else if (tokens.length >= 5) {\n    try {\n      var range = tokenizeRange(tokens);\n      return {\n        context: 'range',\n        feature: range.featureName,\n        range: range\n      };\n    } catch (err) {\n      throw createError('Invalid media feature', err);\n    }\n  }\n\n  throw new Error('Invalid media feature');\n};\nvar tokenizeRange = function tokenizeRange(tokens) {\n  var _a, _b, _c, _d;\n\n  if (tokens.length < 5 || tokens[0].type !== '<(-token>' || tokens[tokens.length - 1].type !== '<)-token>') {\n    throw new Error('Invalid range');\n  }\n\n  var range = {\n    leftToken: null,\n    leftOp: null,\n    featureName: '',\n    rightOp: null,\n    rightToken: null\n  };\n  var hasLeft = tokens[1].type === '<number-token>' || tokens[1].type === '<dimension-token>' || tokens[1].type === '<ratio-token>' || tokens[1].type === '<ident-token>' && tokens[1].value === 'infinite';\n\n  if (tokens[2].type === '<delim-token>') {\n    if (tokens[2].value === 0x003c) {\n      if (tokens[3].type === '<delim-token>' && tokens[3].value === 0x003d && !tokens[3].wsBefore) {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '<=';\n      } else {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '<';\n      }\n    } else if (tokens[2].value === 0x003e) {\n      if (tokens[3].type === '<delim-token>' && tokens[3].value === 0x003d && !tokens[3].wsBefore) {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '>=';\n      } else {\n        range[hasLeft ? 'leftOp' : 'rightOp'] = '>';\n      }\n    } else if (tokens[2].value === 0x003d) {\n      range[hasLeft ? 'leftOp' : 'rightOp'] = '=';\n    } else {\n      throw new Error('Invalid range');\n    }\n\n    if (hasLeft) {\n      range.leftToken = tokens[1];\n    } else if (tokens[1].type === '<ident-token>') {\n      range.featureName = tokens[1].value;\n    } else {\n      throw new Error('Invalid range');\n    }\n\n    var tokenIndexAfterFirstOp = 2 + ((_b = (_a = range[hasLeft ? 'leftOp' : 'rightOp']) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n    var tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];\n\n    if (hasLeft) {\n      if (tokenAfterFirstOp.type === '<ident-token>') {\n        range.featureName = tokenAfterFirstOp.value;\n\n        if (tokens.length >= 7) {\n          var secondOpToken = tokens[tokenIndexAfterFirstOp + 1];\n          var followingToken = tokens[tokenIndexAfterFirstOp + 2];\n\n          if (secondOpToken.type === '<delim-token>') {\n            var charCode = secondOpToken.value;\n\n            if (charCode === 0x003c) {\n              if (followingToken.type === '<delim-token>' && followingToken.value === 0x003d && !followingToken.wsBefore) {\n                range.rightOp = '<=';\n              } else {\n                range.rightOp = '<';\n              }\n            } else if (charCode === 0x003e) {\n              if (followingToken.type === '<delim-token>' && followingToken.value === 0x003d && !followingToken.wsBefore) {\n                range.rightOp = '>=';\n              } else {\n                range.rightOp = '>';\n              }\n            } else {\n              throw new Error('Invalid range');\n            }\n\n            var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];\n            range.rightToken = tokenAfterSecondOp;\n          } else {\n            throw new Error('Invalid range');\n          }\n        } else if (tokenIndexAfterFirstOp + 2 !== tokens.length) {\n          throw new Error('Invalid range');\n        }\n      } else {\n        throw new Error('Invalid range');\n      }\n    } else {\n      range.rightToken = tokenAfterFirstOp;\n    }\n\n    var validRange = null;\n    var lt = range.leftToken,\n        leftOp = range.leftOp,\n        featureName = range.featureName,\n        rightOp = range.rightOp,\n        rt = range.rightToken;\n    var leftToken = null;\n\n    if (lt !== null) {\n      if (lt.type === '<ident-token>') {\n        var type = lt.type,\n            value = lt.value;\n\n        if (value === 'infinite') {\n          leftToken = {\n            type: type,\n            value: value\n          };\n        }\n      } else if (lt.type === '<number-token>' || lt.type === '<dimension-token>' || lt.type === '<ratio-token>') {\n        lt.wsBefore;\n            lt.wsAfter;\n            var ltNoWS = __rest(lt, [\"wsBefore\", \"wsAfter\"]);\n\n        leftToken = ltNoWS;\n      }\n    }\n\n    var rightToken = null;\n\n    if (rt !== null) {\n      if (rt.type === '<ident-token>') {\n        var type = rt.type,\n            value = rt.value;\n\n        if (value === 'infinite') {\n          rightToken = {\n            type: type,\n            value: value\n          };\n        }\n      } else if (rt.type === '<number-token>' || rt.type === '<dimension-token>' || rt.type === '<ratio-token>') {\n        rt.wsBefore;\n            rt.wsAfter;\n            var rtNoWS = __rest(rt, [\"wsBefore\", \"wsAfter\"]);\n\n        rightToken = rtNoWS;\n      }\n    }\n\n    if (leftToken !== null && rightToken !== null) {\n      if ((leftOp === '<' || leftOp === '<=') && (rightOp === '<' || rightOp === '<=')) {\n        validRange = {\n          leftToken: leftToken,\n          leftOp: leftOp,\n          featureName: featureName,\n          rightOp: rightOp,\n          rightToken: rightToken\n        };\n      } else if ((leftOp === '>' || leftOp === '>=') && (rightOp === '>' || rightOp === '>=')) {\n        validRange = {\n          leftToken: leftToken,\n          leftOp: leftOp,\n          featureName: featureName,\n          rightOp: rightOp,\n          rightToken: rightToken\n        };\n      } else {\n        throw new Error('Invalid range');\n      }\n    } else if (leftToken === null && leftOp === null && rightOp !== null && rightToken !== null) {\n      validRange = {\n        leftToken: leftToken,\n        leftOp: leftOp,\n        featureName: featureName,\n        rightOp: rightOp,\n        rightToken: rightToken\n      };\n    } else if (leftToken !== null && leftOp !== null && rightOp === null && rightToken === null) {\n      validRange = {\n        leftToken: leftToken,\n        leftOp: leftOp,\n        featureName: featureName,\n        rightOp: rightOp,\n        rightToken: rightToken\n      };\n    }\n\n    return validRange;\n  } else {\n    throw new Error('Invalid range');\n  }\n};\n\n\n//# sourceMappingURL=media-query-parser.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVkaWEtcXVlcnktcGFyc2VyL2Rpc3QvbWVkaWEtcXVlcnktcGFyc2VyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLG9CQUFvQjtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGdCQUFnQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0NBQXNDLDZCQUE2QjtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxrSEFBa0gsNEJBQTRCO0FBQzlJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRTZUO0FBQzdUIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHhzcGFuZ1xcRGVza3RvcFxcTmV3IGZvbGRlclxcREVWTWF0Y2gtSGFja2F0aG9uLTIwMjVcXG5vZGVfbW9kdWxlc1xcbWVkaWEtcXVlcnktcGFyc2VyXFxkaXN0XFxtZWRpYS1xdWVyeS1wYXJzZXIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBAbGljZW5zZSBNZWRpYVF1ZXJ5UGFyc2VyIC0gTUlUIExpY2Vuc2UgLSBUb20gR29sZGVuIChnaXRodWJAdGJqZ29sZGVuLmNvbSkgKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XG5cbnZhciB3ZWlyZE5ld2xpbmVzID0gLyhcXHUwMDBEfFxcdTAwMEN8XFx1MDAwRFxcdTAwMEEpL2c7XG52YXIgbnVsbE9yU3Vycm9nYXRlcyA9IC9bXFx1MDAwMFxcdUQ4MDAtXFx1REZGRl0vZztcbnZhciBjb21tZW50UmVnZXggPSAvKFxcL1xcKilbXFxzXFxTXSo/KFxcKlxcLykvZztcbnZhciBsZXhpY2FsQW5hbHlzaXMgPSBmdW5jdGlvbiBsZXhpY2FsQW5hbHlzaXMoc3RyLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgIGluZGV4ID0gMDtcbiAgfVxuXG4gIHN0ciA9IHN0ci5yZXBsYWNlKHdlaXJkTmV3bGluZXMsICdcXG4nKS5yZXBsYWNlKG51bGxPclN1cnJvZ2F0ZXMsIFwiXFx1RkZGRFwiKTtcbiAgc3RyID0gc3RyLnJlcGxhY2UoY29tbWVudFJlZ2V4LCAnJyk7XG4gIHZhciB0b2tlbnMgPSBbXTtcblxuICBmb3IgKDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICBpZiAoY29kZSA9PT0gMHgwMDA5IHx8IGNvZGUgPT09IDB4MDAyMCB8fCBjb2RlID09PSAweDAwMGEpIHtcbiAgICAgIHZhciBjb2RlXzEgPSBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcblxuICAgICAgd2hpbGUgKGNvZGVfMSA9PT0gMHgwMDA5IHx8IGNvZGVfMSA9PT0gMHgwMDIwIHx8IGNvZGVfMSA9PT0gMHgwMDBhKSB7XG4gICAgICAgIGNvZGVfMSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpbmRleCAtPSAxO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHdoaXRlc3BhY2UtdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMjIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lU3RyaW5nKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfYVswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9hWzFdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8c3RyaW5nLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyMykge1xuICAgICAgaWYgKGluZGV4ICsgMSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgICBpZiAobmV4dENvZGUgPT09IDB4MDA1ZiB8fCBuZXh0Q29kZSA+PSAweDAwNDEgJiYgbmV4dENvZGUgPD0gMHgwMDVhIHx8IG5leHRDb2RlID49IDB4MDA2MSAmJiBuZXh0Q29kZSA8PSAweDAwN2EgfHwgbmV4dENvZGUgPj0gMHgwMDgwIHx8IG5leHRDb2RlID49IDB4MDAzMCAmJiBuZXh0Q29kZSA8PSAweDAwMzkgfHwgbmV4dENvZGUgPT09IDB4MDA1YyAmJiBpbmRleCArIDIgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMikgIT09IDB4MDAwYSkge1xuICAgICAgICAgIHZhciBmbGFnID0gd291bGRTdGFydElkZW50aWZpZXIoc3RyLCBpbmRleCArIDEpID8gJ2lkJyA6ICd1bnJlc3RyaWN0ZWQnO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lSWRlbnRVbnNhZmUoc3RyLCBpbmRleCArIDEpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gX2JbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfYlsxXTtcblxuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAnPGhhc2gtdG9rZW4+JyxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgIGZsYWc6IGZsYWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyNykge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVTdHJpbmcoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfYyA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9jWzBdLFxuICAgICAgICAgIHZhbHVlID0gX2NbMV07XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxzdHJpbmctdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDI4KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8KC10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyOSkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPCktdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMmIpIHtcbiAgICAgIHZhciBwbHVzTnVtZXJpYyA9IGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocGx1c051bWVyaWMgPT09IG51bGwpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZCA9IF9fcmVhZChwbHVzTnVtZXJpYywgMiksXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBfZFswXSxcbiAgICAgICAgICAgIHRva2VuVHVwbGUgPSBfZFsxXTtcblxuICAgICAgICBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+Jykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICc8ZGltZW5zaW9uLXRva2VuPicsXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIHVuaXQ6IHRva2VuVHVwbGVbMl0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxudW1iZXItdG9rZW4+Jykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIGZsYWc6IHRva2VuVHVwbGVbMl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMmMpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxjb21tYS10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyZCkge1xuICAgICAgdmFyIG1pbnVzTnVtZXJpYyA9IGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAobWludXNOdW1lcmljICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfZSA9IF9fcmVhZChtaW51c051bWVyaWMsIDIpLFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gX2VbMF0sXG4gICAgICAgICAgICB0b2tlblR1cGxlID0gX2VbMV07XG5cbiAgICAgICAgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8ZGltZW5zaW9uLXRva2VuPicpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPGRpbWVuc2lvbi10b2tlbj4nLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICB1bml0OiB0b2tlblR1cGxlWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8bnVtYmVyLXRva2VuPicpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICBmbGFnOiB0b2tlblR1cGxlWzJdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICsgMiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMik7XG5cbiAgICAgICAgaWYgKG5leHRDb2RlID09PSAweDAwMmQgJiYgbmV4dE5leHRDb2RlID09PSAweDAwM2UpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPENEQy10b2tlbj4nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUlkZW50TGlrZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2YgPSBfX3JlYWQocmVzdWx0LCAzKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9mWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfZlsxXSxcbiAgICAgICAgICAgIHR5cGUgPSBfZlsyXTtcblxuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyZSkge1xuICAgICAgdmFyIG1pbnVzTnVtZXJpYyA9IGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAobWludXNOdW1lcmljID09PSBudWxsKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2cgPSBfX3JlYWQobWludXNOdW1lcmljLCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9nWzBdLFxuICAgICAgICAgICAgdG9rZW5UdXBsZSA9IF9nWzFdO1xuXG4gICAgICAgIGlmICh0b2tlblR1cGxlWzBdID09PSAnPGRpbWVuc2lvbi10b2tlbj4nKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJzxkaW1lbnNpb24tdG9rZW4+JyxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgdW5pdDogdG9rZW5UdXBsZVsyXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlblR1cGxlWzBdID09PSAnPG51bWJlci10b2tlbj4nKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgZmxhZzogdG9rZW5UdXBsZVsyXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwM2EpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxjb2xvbi10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAzYikge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHNlbWljb2xvbi10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAzYykge1xuICAgICAgaWYgKGluZGV4ICsgMyA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMik7XG4gICAgICAgIHZhciBuZXh0TmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAzKTtcblxuICAgICAgICBpZiAobmV4dENvZGUgPT09IDB4MDAyMSAmJiBuZXh0TmV4dENvZGUgPT09IDB4MDAyZCAmJiBuZXh0TmV4dE5leHRDb2RlID09PSAweDAwMmQpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPENETy10b2tlbj4nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDQwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUlkZW50KHN0ciwgaW5kZXggKyAxKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2ggPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9oWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfaFsxXTtcblxuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJzxhdC1rZXl3b3JkLXRva2VuPicsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1Yikge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPFstdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lRXNjYXBlKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2ogPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfalswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9qWzFdO1xuXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgaW5kZXgpICsgdmFsdWUgKyBzdHIuc2xpY2UobGFzdEluZGV4ICsgMSk7XG4gICAgICBpbmRleCAtPSAxO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVkKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8XS10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA3Yikge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHstdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwN2QpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzx9LXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lTnVtZXJpYyhzdHIsIGluZGV4KTtcblxuICAgICAgdmFyIF9rID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2tbMF0sXG4gICAgICAgICAgdG9rZW5UdXBsZSA9IF9rWzFdO1xuXG4gICAgICBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+Jykge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJzxkaW1lbnNpb24tdG9rZW4+JyxcbiAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICB1bml0OiB0b2tlblR1cGxlWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8bnVtYmVyLXRva2VuPicpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgZmxhZzogdG9rZW5UdXBsZVsyXVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1ZiB8fCBjb2RlID49IDB4MDA0MSAmJiBjb2RlIDw9IDB4MDA1YSB8fCBjb2RlID49IDB4MDA2MSAmJiBjb2RlIDw9IDB4MDA3YSB8fCBjb2RlID49IDB4MDA4MCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVJZGVudExpa2Uoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbCA9IF9fcmVhZChyZXN1bHQsIDMpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9sWzBdLFxuICAgICAgICAgIHZhbHVlID0gX2xbMV0sXG4gICAgICAgICAgdHlwZSA9IF9sWzJdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB0b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJzxFT0YtdG9rZW4+J1xuICB9KTtcbiAgcmV0dXJuIHRva2Vucztcbn07XG52YXIgY29uc3VtZVN0cmluZyA9IGZ1bmN0aW9uIGNvbnN1bWVTdHJpbmcoc3RyLCBpbmRleCkge1xuICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCArIDEpIHJldHVybiBudWxsO1xuICB2YXIgZmlyc3RDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICB2YXIgY2hhckNvZGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IGluZGV4ICsgMTsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoY29kZSA9PT0gZmlyc3RDb2RlKSB7XG4gICAgICByZXR1cm4gW2ksIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2hhckNvZGVzKV07XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lRXNjYXBlKHN0ciwgaSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIF9hID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICAgICAgY2hhckNvZGUgPSBfYVsxXTtcblxuICAgICAgY2hhckNvZGVzLnB1c2goY2hhckNvZGUpO1xuICAgICAgaSA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAwYSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYXJDb2Rlcy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbnZhciB3b3VsZFN0YXJ0SWRlbnRpZmllciA9IGZ1bmN0aW9uIHdvdWxkU3RhcnRJZGVudGlmaWVyKHN0ciwgaW5kZXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgaWYgKGNvZGUgPT09IDB4MDAyZCkge1xuICAgIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4ICsgMSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cbiAgICBpZiAobmV4dENvZGUgPT09IDB4MDAyZCB8fCBuZXh0Q29kZSA9PT0gMHgwMDVmIHx8IG5leHRDb2RlID49IDB4MDA0MSAmJiBuZXh0Q29kZSA8PSAweDAwNWEgfHwgbmV4dENvZGUgPj0gMHgwMDYxICYmIG5leHRDb2RlIDw9IDB4MDA3YSB8fCBuZXh0Q29kZSA+PSAweDAwODApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobmV4dENvZGUgPT09IDB4MDA1Yykge1xuICAgICAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXggKyAyKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAyKTtcbiAgICAgIHJldHVybiBuZXh0TmV4dENvZGUgIT09IDB4MDAwYTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWYgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EgfHwgY29kZSA+PSAweDAwODApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCArIDEpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgIHJldHVybiBuZXh0Q29kZSAhPT0gMHgwMDBhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBjb25zdW1lRXNjYXBlID0gZnVuY3Rpb24gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4ICsgMSkgcmV0dXJuIG51bGw7XG4gIGlmIChzdHIuY2hhckNvZGVBdChpbmRleCkgIT09IDB4MDA1YykgcmV0dXJuIG51bGw7XG4gIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICBpZiAoY29kZSA9PT0gMHgwMDBhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNDYgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwNjYpIHtcbiAgICB2YXIgaGV4Q2hhckNvZGVzID0gW2NvZGVdO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihpbmRleCArIDcsIHN0ci5sZW5ndGgpO1xuICAgIHZhciBpID0gaW5kZXggKyAyO1xuXG4gICAgZm9yICg7IGkgPCBtaW47IGkgKz0gMSkge1xuICAgICAgdmFyIGNvZGVfMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoY29kZV8yID49IDB4MDAzMCAmJiBjb2RlXzIgPD0gMHgwMDM5IHx8IGNvZGVfMiA+PSAweDAwNDEgJiYgY29kZV8yIDw9IDB4MDA0NiB8fCBjb2RlXzIgPj0gMHgwMDYxICYmIGNvZGVfMiA8PSAweDAwNjYpIHtcbiAgICAgICAgaGV4Q2hhckNvZGVzLnB1c2goY29kZV8yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgdmFyIGNvZGVfMyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoY29kZV8zID09PSAweDAwMDkgfHwgY29kZV8zID09PSAweDAwMjAgfHwgY29kZV8zID09PSAweDAwMGEpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbaSAtIDEsIHBhcnNlSW50KFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaGV4Q2hhckNvZGVzKSwgMTYpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2luZGV4ICsgMSwgY29kZV07XG4gIH1cbn07XG52YXIgY29uc3VtZU51bWVyaWMgPSBmdW5jdGlvbiBjb25zdW1lTnVtZXJpYyhzdHIsIGluZGV4KSB7XG4gIHZhciBudW1iZXJSZXN1bHQgPSBjb25zdW1lTnVtYmVyKHN0ciwgaW5kZXgpO1xuICBpZiAobnVtYmVyUmVzdWx0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICB2YXIgX2EgPSBfX3JlYWQobnVtYmVyUmVzdWx0LCAzKSxcbiAgICAgIG51bWJlckVuZEluZGV4ID0gX2FbMF0sXG4gICAgICBudW1iZXJWYWx1ZSA9IF9hWzFdLFxuICAgICAgbnVtYmVyRmxhZyA9IF9hWzJdO1xuXG4gIHZhciBpZGVudFJlc3VsdCA9IGNvbnN1bWVJZGVudChzdHIsIG51bWJlckVuZEluZGV4ICsgMSk7XG5cbiAgaWYgKGlkZW50UmVzdWx0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9iID0gX19yZWFkKGlkZW50UmVzdWx0LCAyKSxcbiAgICAgICAgaWRlbnRFbmRJbmRleCA9IF9iWzBdLFxuICAgICAgICBpZGVudFZhbHVlID0gX2JbMV07XG5cbiAgICByZXR1cm4gW2lkZW50RW5kSW5kZXgsIFsnPGRpbWVuc2lvbi10b2tlbj4nLCBudW1iZXJWYWx1ZSwgaWRlbnRWYWx1ZV1dO1xuICB9XG5cbiAgaWYgKG51bWJlckVuZEluZGV4ICsgMSA8IHN0ci5sZW5ndGggJiYgc3RyLmNoYXJDb2RlQXQobnVtYmVyRW5kSW5kZXggKyAxKSA9PT0gMHgwMDI1KSB7XG4gICAgcmV0dXJuIFtudW1iZXJFbmRJbmRleCArIDEsIFsnPHBlcmNlbnRhZ2UtdG9rZW4+JywgbnVtYmVyVmFsdWVdXTtcbiAgfVxuXG4gIHJldHVybiBbbnVtYmVyRW5kSW5kZXgsIFsnPG51bWJlci10b2tlbj4nLCBudW1iZXJWYWx1ZSwgbnVtYmVyRmxhZ11dO1xufTtcbnZhciBjb25zdW1lTnVtYmVyID0gZnVuY3Rpb24gY29uc3VtZU51bWJlcihzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4KSByZXR1cm4gbnVsbDtcbiAgdmFyIGZsYWcgPSAnaW50ZWdlcic7XG4gIHZhciBudW1iZXJDaGFycyA9IFtdO1xuICB2YXIgZmlyc3RDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIGlmIChmaXJzdENvZGUgPT09IDB4MDAyYiB8fCBmaXJzdENvZGUgPT09IDB4MDAyZCkge1xuICAgIGluZGV4ICs9IDE7XG4gICAgaWYgKGZpcnN0Q29kZSA9PT0gMHgwMDJkKSBudW1iZXJDaGFycy5wdXNoKDB4MDAyZCk7XG4gIH1cblxuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIG51bWJlckNoYXJzLnB1c2goY29kZSk7XG4gICAgICBpbmRleCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaW5kZXggKyAxIDwgc3RyLmxlbmd0aCkge1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICB2YXIgbmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDJlICYmIG5leHROZXh0Q29kZSA+PSAweDAwMzAgJiYgbmV4dE5leHRDb2RlIDw9IDB4MDAzOSkge1xuICAgICAgbnVtYmVyQ2hhcnMucHVzaChuZXh0Q29kZSwgbmV4dE5leHRDb2RlKTtcbiAgICAgIGZsYWcgPSAnbnVtYmVyJztcbiAgICAgIGluZGV4ICs9IDI7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgaWYgKGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5KSB7XG4gICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaChjb2RlKTtcbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGV4ICsgMSA8IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgdmFyIG5leHROZXh0TmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDIpO1xuXG4gICAgaWYgKG5leHRDb2RlID09PSAweDAwNDUgfHwgbmV4dENvZGUgPT09IDB4MDA2NSkge1xuICAgICAgdmFyIG5leHROZXh0SXNEaWdpdCA9IG5leHROZXh0Q29kZSA+PSAweDAwMzAgJiYgbmV4dE5leHRDb2RlIDw9IDB4MDAzOTtcblxuICAgICAgaWYgKG5leHROZXh0SXNEaWdpdCB8fCAobmV4dE5leHRDb2RlID09PSAweDAwMmIgfHwgbmV4dE5leHRDb2RlID09PSAweDAwMmQpICYmIG5leHROZXh0TmV4dENvZGUgPj0gMHgwMDMwICYmIG5leHROZXh0TmV4dENvZGUgPD0gMHgwMDM5KSB7XG4gICAgICAgIGZsYWcgPSAnbnVtYmVyJztcblxuICAgICAgICBpZiAobmV4dE5leHRJc0RpZ2l0KSB7XG4gICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaCgweDAwNDUsIG5leHROZXh0Q29kZSk7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0TmV4dENvZGUgPT09IDB4MDAyZCkge1xuICAgICAgICAgIG51bWJlckNoYXJzLnB1c2goMHgwMDQ1LCAweDAwMmQsIG5leHROZXh0TmV4dENvZGUpO1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaCgweDAwNDUsIG5leHROZXh0TmV4dENvZGUpO1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgICBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgICAgICAgIG51bWJlckNoYXJzLnB1c2goY29kZSk7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbnVtYmVyU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBudW1iZXJDaGFycyk7XG4gIHZhciB2YWx1ZSA9IGZsYWcgPT09ICdudW1iZXInID8gcGFyc2VGbG9hdChudW1iZXJTdHJpbmcpIDogcGFyc2VJbnQobnVtYmVyU3RyaW5nKTtcbiAgaWYgKHZhbHVlID09PSAtMCkgdmFsdWUgPSAwO1xuICByZXR1cm4gTnVtYmVyLmlzTmFOKHZhbHVlKSA/IG51bGwgOiBbaW5kZXggLSAxLCB2YWx1ZSwgZmxhZ107XG59O1xudmFyIGNvbnN1bWVJZGVudFVuc2FmZSA9IGZ1bmN0aW9uIGNvbnN1bWVJZGVudFVuc2FmZShzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaWRlbnRDaGFycyA9IFtdO1xuXG4gIGZvciAodmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7IGluZGV4IDwgc3RyLmxlbmd0aDsgY29kZSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpKSB7XG4gICAgaWYgKGNvZGUgPT09IDB4MDAyZCB8fCBjb2RlID09PSAweDAwNWYgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EgfHwgY29kZSA+PSAweDAwODAgfHwgY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIGlkZW50Q2hhcnMucHVzaChjb2RlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9hWzBdLFxuICAgICAgICAgICAgY29kZV80ID0gX2FbMV07XG5cbiAgICAgICAgaWRlbnRDaGFycy5wdXNoKGNvZGVfNCk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBpbmRleCA9PT0gMCA/IG51bGwgOiBbaW5kZXggLSAxLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlkZW50Q2hhcnMpXTtcbn07XG52YXIgY29uc3VtZUlkZW50ID0gZnVuY3Rpb24gY29uc3VtZUlkZW50KHN0ciwgaW5kZXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXggfHwgIXdvdWxkU3RhcnRJZGVudGlmaWVyKHN0ciwgaW5kZXgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaWRlbnRDaGFycyA9IFtdO1xuXG4gIGZvciAodmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7IGluZGV4IDwgc3RyLmxlbmd0aDsgY29kZSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpKSB7XG4gICAgaWYgKGNvZGUgPT09IDB4MDAyZCB8fCBjb2RlID09PSAweDAwNWYgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EgfHwgY29kZSA+PSAweDAwODAgfHwgY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIGlkZW50Q2hhcnMucHVzaChjb2RlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9hWzBdLFxuICAgICAgICAgICAgY29kZV81ID0gX2FbMV07XG5cbiAgICAgICAgaWRlbnRDaGFycy5wdXNoKGNvZGVfNSk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBbaW5kZXggLSAxLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlkZW50Q2hhcnMpXTtcbn07XG52YXIgY29uc3VtZVVybCA9IGZ1bmN0aW9uIGNvbnN1bWVVcmwoc3RyLCBpbmRleCkge1xuICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcblxuICB3aGlsZSAoY29kZSA9PT0gMHgwMDA5IHx8IGNvZGUgPT09IDB4MDAyMCB8fCBjb2RlID09PSAweDAwMGEpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoKytpbmRleCk7XG4gIH1cblxuICB2YXIgdXJsQ2hhcnMgPSBbXTtcbiAgdmFyIGhhc0ZpbmlzaGVkV29yZCA9IGZhbHNlO1xuXG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBpZiAoY29kZSA9PT0gMHgwMDI5KSB7XG4gICAgICByZXR1cm4gW2luZGV4LCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHVybENoYXJzKV07XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMjIgfHwgY29kZSA9PT0gMHgwMDI3IHx8IGNvZGUgPT09IDB4MDAyOCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMDkgfHwgY29kZSA9PT0gMHgwMDIwIHx8IGNvZGUgPT09IDB4MDAwYSkge1xuICAgICAgaWYgKCFoYXNGaW5pc2hlZFdvcmQgJiYgdXJsQ2hhcnMubGVuZ3RoICE9PSAwKSBoYXNGaW5pc2hlZFdvcmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVjKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgaGFzRmluaXNoZWRXb3JkKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIF9hID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfYVsxXTtcblxuICAgICAgdXJsQ2hhcnMucHVzaCh2YWx1ZSk7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc0ZpbmlzaGVkV29yZCkgcmV0dXJuIG51bGw7XG4gICAgICB1cmxDaGFycy5wdXNoKGNvZGUpO1xuICAgIH1cblxuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbnZhciBjb25zdW1lSWRlbnRMaWtlID0gZnVuY3Rpb24gY29uc3VtZUlkZW50TGlrZShzdHIsIGluZGV4KSB7XG4gIHZhciByZXN1bHQgPSBjb25zdW1lSWRlbnQoc3RyLCBpbmRleCk7XG4gIGlmIChyZXN1bHQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIHZhciBfYSA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICB2YWx1ZSA9IF9hWzFdO1xuXG4gIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndXJsJykge1xuICAgIGlmIChzdHIubGVuZ3RoID4gbGFzdEluZGV4ICsgMSkge1xuICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQobGFzdEluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDI4KSB7XG4gICAgICAgIGZvciAodmFyIG9mZnNldCA9IDI7IGxhc3RJbmRleCArIG9mZnNldCA8IHN0ci5sZW5ndGg7IG9mZnNldCArPSAxKSB7XG4gICAgICAgICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJbmRleCArIG9mZnNldCk7XG5cbiAgICAgICAgICBpZiAobmV4dE5leHRDb2RlID09PSAweDAwMjIgfHwgbmV4dE5leHRDb2RlID09PSAweDAwMjcpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGFzdEluZGV4ICsgMSwgdmFsdWUudG9Mb3dlckNhc2UoKSwgJzxmdW5jdGlvbi10b2tlbj4nXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHROZXh0Q29kZSAhPT0gMHgwMDA5ICYmIG5leHROZXh0Q29kZSAhPT0gMHgwMDIwICYmIG5leHROZXh0Q29kZSAhPT0gMHgwMDBhKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSBjb25zdW1lVXJsKHN0ciwgbGFzdEluZGV4ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRfMSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChyZXN1bHRfMSwgMiksXG4gICAgICAgICAgICAgICAgbGFzdFVybEluZGV4ID0gX2JbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWVfMSA9IF9iWzFdO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xhc3RVcmxJbmRleCwgdmFsdWVfMSwgJzx1cmwtdG9rZW4+J107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsYXN0SW5kZXggKyAxLCB2YWx1ZS50b0xvd2VyQ2FzZSgpLCAnPGZ1bmN0aW9uLXRva2VuPiddO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID4gbGFzdEluZGV4ICsgMSkge1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJbmRleCArIDEpO1xuXG4gICAgaWYgKG5leHRDb2RlID09PSAweDAwMjgpIHtcbiAgICAgIHJldHVybiBbbGFzdEluZGV4ICsgMSwgdmFsdWUudG9Mb3dlckNhc2UoKSwgJzxmdW5jdGlvbi10b2tlbj4nXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2xhc3RJbmRleCwgdmFsdWUudG9Mb3dlckNhc2UoKSwgJzxpZGVudC10b2tlbj4nXTtcbn07XG5cbnZhciBzaW1wbGlmeUFTVCA9IGZ1bmN0aW9uIHNpbXBsaWZ5QVNUKGFzdCkge1xuICBmb3IgKHZhciBpID0gYXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgYXN0W2ldID0gc2ltcGxpZnlNZWRpYVF1ZXJ5KGFzdFtpXSk7XG4gIH1cblxuICByZXR1cm4gYXN0O1xufTtcblxudmFyIHNpbXBsaWZ5TWVkaWFRdWVyeSA9IGZ1bmN0aW9uIHNpbXBsaWZ5TWVkaWFRdWVyeShtZWRpYVF1ZXJ5KSB7XG4gIGlmIChtZWRpYVF1ZXJ5Lm1lZGlhQ29uZGl0aW9uID09PSBudWxsKSByZXR1cm4gbWVkaWFRdWVyeTtcbiAgdmFyIG1lZGlhQ29uZGl0aW9uID0gc2ltcGxpZnlNZWRpYUNvbmRpdGlvbihtZWRpYVF1ZXJ5Lm1lZGlhQ29uZGl0aW9uKTtcblxuICBpZiAobWVkaWFDb25kaXRpb24ub3BlcmF0b3IgPT09IG51bGwgJiYgbWVkaWFDb25kaXRpb24uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmICdjaGlsZHJlbicgaW4gbWVkaWFDb25kaXRpb24uY2hpbGRyZW5bMF0pIHtcbiAgICBtZWRpYUNvbmRpdGlvbiA9IG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuWzBdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZWRpYVByZWZpeDogbWVkaWFRdWVyeS5tZWRpYVByZWZpeCxcbiAgICBtZWRpYVR5cGU6IG1lZGlhUXVlcnkubWVkaWFUeXBlLFxuICAgIG1lZGlhQ29uZGl0aW9uOiBtZWRpYUNvbmRpdGlvblxuICB9O1xufTtcblxudmFyIHNpbXBsaWZ5TWVkaWFDb25kaXRpb24gPSBmdW5jdGlvbiBzaW1wbGlmeU1lZGlhQ29uZGl0aW9uKG1lZGlhQ29uZGl0aW9uKSB7XG4gIGZvciAodmFyIGkgPSBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciB1bnNpbXBsaWZpZWRDaGlsZCA9IG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKCEoJ2NvbnRleHQnIGluIHVuc2ltcGxpZmllZENoaWxkKSkge1xuICAgICAgdmFyIGNoaWxkID0gc2ltcGxpZnlNZWRpYUNvbmRpdGlvbih1bnNpbXBsaWZpZWRDaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZC5vcGVyYXRvciA9PT0gbnVsbCAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbWVkaWFDb25kaXRpb24uY2hpbGRyZW5baV0gPSBjaGlsZC5jaGlsZHJlblswXTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQub3BlcmF0b3IgPT09IG1lZGlhQ29uZGl0aW9uLm9wZXJhdG9yICYmIChjaGlsZC5vcGVyYXRvciA9PT0gJ2FuZCcgfHwgY2hpbGQub3BlcmF0b3IgPT09ICdvcicpKSB7XG4gICAgICAgIHZhciBzcGxpY2VBcmdzID0gW2ksIDFdO1xuXG4gICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaV8xKyspIHtcbiAgICAgICAgICBzcGxpY2VBcmdzLnB1c2goY2hpbGQuY2hpbGRyZW5baV8xXSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlbi5zcGxpY2UuYXBwbHkobWVkaWFDb25kaXRpb24uY2hpbGRyZW4sIHNwbGljZUFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZWRpYUNvbmRpdGlvbjtcbn07XG5cbnZhciBjcmVhdGVFcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGVycikge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiXCIuY29uY2F0KGVyci5tZXNzYWdlLnRyaW0oKSwgXCJcXG5cIikuY29uY2F0KG1lc3NhZ2UudHJpbSgpKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlLnRyaW0oKSk7XG4gIH1cbn07XG5cbnZhciB0b0FTVCA9IGZ1bmN0aW9uIHRvQVNUKHN0cikge1xuICByZXR1cm4gc2ltcGxpZnlBU1QodG9VbmZsYXR0ZW5lZEFTVChzdHIpKTtcbn07XG52YXIgdG9VbmZsYXR0ZW5lZEFTVCA9IGZ1bmN0aW9uIHRvVW5mbGF0dGVuZWRBU1Qoc3RyKSB7XG4gIHZhciB0b2tlbkxpc3QgPSBsZXhpY2FsQW5hbHlzaXMoc3RyLnRyaW0oKSk7XG5cbiAgaWYgKHRva2VuTGlzdCA9PT0gbnVsbCkge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKCdGYWlsZWQgdG9rZW5pemluZycpO1xuICB9XG5cbiAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICB2YXIgZW5kSW5kZXggPSB0b2tlbkxpc3QubGVuZ3RoIC0gMTtcblxuICBpZiAodG9rZW5MaXN0WzBdLnR5cGUgPT09ICc8YXQta2V5d29yZC10b2tlbj4nICYmIHRva2VuTGlzdFswXS52YWx1ZSA9PT0gJ21lZGlhJykge1xuICAgIGlmICh0b2tlbkxpc3RbMV0udHlwZSAhPT0gJzx3aGl0ZXNwYWNlLXRva2VuPicpIHtcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdFeHBlY3RlZCB3aGl0ZXNwYWNlIGFmdGVyIG1lZGlhJyk7XG4gICAgfVxuXG4gICAgc3RhcnRJbmRleCA9IDI7XG5cbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHRva2VuTGlzdC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2VuTGlzdFtpXTtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICc8ey10b2tlbj4nKSB7XG4gICAgICAgIGVuZEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICc8c2VtaWNvbG9uLXRva2VuPicpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCAneycgaW4gbWVkaWEgcXVlcnkgYnV0IGZvdW5kICc7J1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b2tlbkxpc3QgPSB0b2tlbkxpc3Quc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICByZXR1cm4gc3ludGFjdGljQW5hbHlzaXModG9rZW5MaXN0KTtcbn07XG52YXIgcmVtb3ZlV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIHJlbW92ZVdoaXRlc3BhY2UodG9rZW5MaXN0KSB7XG4gIHZhciBuZXdUb2tlbkxpc3QgPSBbXTtcbiAgdmFyIGJlZm9yZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRva2VuTGlzdFtpXS50eXBlID09PSAnPHdoaXRlc3BhY2UtdG9rZW4+Jykge1xuICAgICAgYmVmb3JlID0gdHJ1ZTtcblxuICAgICAgaWYgKG5ld1Rva2VuTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5ld1Rva2VuTGlzdFtuZXdUb2tlbkxpc3QubGVuZ3RoIC0gMV0ud3NBZnRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Rva2VuTGlzdC5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0b2tlbkxpc3RbaV0pLCB7XG4gICAgICAgIHdzQmVmb3JlOiBiZWZvcmUsXG4gICAgICAgIHdzQWZ0ZXI6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgICBiZWZvcmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VG9rZW5MaXN0O1xufTtcbnZhciBzeW50YWN0aWNBbmFseXNpcyA9IGZ1bmN0aW9uIHN5bnRhY3RpY0FuYWx5c2lzKHRva2VuTGlzdCkge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgbWVkaWFRdWVyeUxpc3QgPSBbW11dO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5MaXN0W2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICc8Y29tbWEtdG9rZW4+Jykge1xuICAgICAgbWVkaWFRdWVyeUxpc3QucHVzaChbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lZGlhUXVlcnlMaXN0W21lZGlhUXVlcnlMaXN0Lmxlbmd0aCAtIDFdLnB1c2godG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtZWRpYVF1ZXJpZXMgPSBtZWRpYVF1ZXJ5TGlzdC5tYXAocmVtb3ZlV2hpdGVzcGFjZSk7XG5cbiAgaWYgKG1lZGlhUXVlcmllcy5sZW5ndGggPT09IDEgJiYgbWVkaWFRdWVyaWVzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbe1xuICAgICAgbWVkaWFDb25kaXRpb246IG51bGwsXG4gICAgICBtZWRpYVByZWZpeDogbnVsbCxcbiAgICAgIG1lZGlhVHlwZTogJ2FsbCdcbiAgICB9XTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWVkaWFRdWVyeVRva2VucyA9IG1lZGlhUXVlcmllcy5tYXAoZnVuY3Rpb24gKG1lZGlhUXVlcnlUb2tlbnMpIHtcbiAgICAgIGlmIChtZWRpYVF1ZXJ5VG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbml6ZU1lZGlhUXVlcnkobWVkaWFRdWVyeVRva2Vucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG5vbk51bGxNZWRpYVF1ZXJ5VG9rZW5zID0gW107XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgbWVkaWFRdWVyeVRva2Vuc18xID0gX192YWx1ZXMobWVkaWFRdWVyeVRva2VucyksIG1lZGlhUXVlcnlUb2tlbnNfMV8xID0gbWVkaWFRdWVyeVRva2Vuc18xLm5leHQoKTsgIW1lZGlhUXVlcnlUb2tlbnNfMV8xLmRvbmU7IG1lZGlhUXVlcnlUb2tlbnNfMV8xID0gbWVkaWFRdWVyeVRva2Vuc18xLm5leHQoKSkge1xuICAgICAgICB2YXIgbWVkaWFRdWVyeVRva2VuID0gbWVkaWFRdWVyeVRva2Vuc18xXzEudmFsdWU7XG5cbiAgICAgICAgaWYgKG1lZGlhUXVlcnlUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vbk51bGxNZWRpYVF1ZXJ5VG9rZW5zLnB1c2gobWVkaWFRdWVyeVRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICBlXzEgPSB7XG4gICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG1lZGlhUXVlcnlUb2tlbnNfMV8xICYmICFtZWRpYVF1ZXJ5VG9rZW5zXzFfMS5kb25lICYmIChfYSA9IG1lZGlhUXVlcnlUb2tlbnNfMVtcInJldHVyblwiXSkpIF9hLmNhbGwobWVkaWFRdWVyeVRva2Vuc18xKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9uTnVsbE1lZGlhUXVlcnlUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcignTm8gdmFsaWQgbWVkaWEgcXVlcmllcycpO1xuICAgIH1cblxuICAgIHJldHVybiBub25OdWxsTWVkaWFRdWVyeVRva2VucztcbiAgfVxufTtcbnZhciB0b2tlbml6ZU1lZGlhUXVlcnkgPSBmdW5jdGlvbiB0b2tlbml6ZU1lZGlhUXVlcnkodG9rZW5zKSB7XG4gIHZhciBmaXJzdFRva2VuID0gdG9rZW5zWzBdO1xuXG4gIGlmIChmaXJzdFRva2VuLnR5cGUgPT09ICc8KC10b2tlbj4nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lZGlhUHJlZml4OiBudWxsLFxuICAgICAgICBtZWRpYVR5cGU6ICdhbGwnLFxuICAgICAgICBtZWRpYUNvbmRpdGlvbjogdG9rZW5pemVNZWRpYUNvbmRpdGlvbih0b2tlbnMsIHRydWUpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCBtZWRpYSBjb25kaXRpb24gYWZ0ZXIgJygnXCIsIGVycik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZpcnN0VG9rZW4udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgdmFyIG1lZGlhUHJlZml4ID0gbnVsbDtcbiAgICB2YXIgbWVkaWFUeXBlID0gdm9pZCAwO1xuICAgIHZhciB2YWx1ZSA9IGZpcnN0VG9rZW4udmFsdWU7XG5cbiAgICBpZiAodmFsdWUgPT09ICdvbmx5JyB8fCB2YWx1ZSA9PT0gJ25vdCcpIHtcbiAgICAgIG1lZGlhUHJlZml4ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5kZXggPSBtZWRpYVByZWZpeCA9PT0gbnVsbCA/IDAgOiAxO1xuXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPD0gZmlyc3RJbmRleCkge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCBleHRyYSB0b2tlbiBpbiBtZWRpYSBxdWVyeVwiKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3ROb25VbmFyeVRva2VuID0gdG9rZW5zW2ZpcnN0SW5kZXhdO1xuXG4gICAgaWYgKGZpcnN0Tm9uVW5hcnlUb2tlbi50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgIHZhciB2YWx1ZV8xID0gZmlyc3ROb25VbmFyeVRva2VuLnZhbHVlO1xuXG4gICAgICBpZiAodmFsdWVfMSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgbWVkaWFUeXBlID0gJ2FsbCc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlXzEgPT09ICdwcmludCcgfHwgdmFsdWVfMSA9PT0gJ3NjcmVlbicpIHtcbiAgICAgICAgbWVkaWFUeXBlID0gdmFsdWVfMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWVfMSA9PT0gJ3R0eScgfHwgdmFsdWVfMSA9PT0gJ3R2JyB8fCB2YWx1ZV8xID09PSAncHJvamVjdGlvbicgfHwgdmFsdWVfMSA9PT0gJ2hhbmRoZWxkJyB8fCB2YWx1ZV8xID09PSAnYnJhaWxsZScgfHwgdmFsdWVfMSA9PT0gJ2VtYm9zc2VkJyB8fCB2YWx1ZV8xID09PSAnYXVyYWwnIHx8IHZhbHVlXzEgPT09ICdzcGVlY2gnKSB7XG4gICAgICAgIG1lZGlhUHJlZml4ID0gbWVkaWFQcmVmaXggPT09ICdub3QnID8gbnVsbCA6ICdub3QnO1xuICAgICAgICBtZWRpYVR5cGUgPSAnYWxsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiVW5rbm93biBpZGVudCAnXCIuY29uY2F0KHZhbHVlXzEsIFwiJyBpbiBtZWRpYSBxdWVyeVwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZWRpYVByZWZpeCA9PT0gJ25vdCcgJiYgZmlyc3ROb25VbmFyeVRva2VuLnR5cGUgPT09ICc8KC10b2tlbj4nKSB7XG4gICAgICB2YXIgdG9rZW5zV2l0aFBhcmVucyA9IFt7XG4gICAgICAgIHR5cGU6ICc8KC10b2tlbj4nLFxuICAgICAgICB3c0JlZm9yZTogZmFsc2UsXG4gICAgICAgIHdzQWZ0ZXI6IGZhbHNlXG4gICAgICB9XTtcbiAgICAgIHRva2Vuc1dpdGhQYXJlbnMucHVzaC5hcHBseSh0b2tlbnNXaXRoUGFyZW5zLCB0b2tlbnMpO1xuICAgICAgdG9rZW5zV2l0aFBhcmVucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzwpLXRva2VuPicsXG4gICAgICAgIHdzQmVmb3JlOiBmYWxzZSxcbiAgICAgICAgd3NBZnRlcjogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1lZGlhUHJlZml4OiBudWxsLFxuICAgICAgICAgIG1lZGlhVHlwZTogJ2FsbCcsXG4gICAgICAgICAgbWVkaWFDb25kaXRpb246IHRva2VuaXplTWVkaWFDb25kaXRpb24odG9rZW5zV2l0aFBhcmVucywgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIkV4cGVjdGVkIG1lZGlhIGNvbmRpdGlvbiBhZnRlciAnKCdcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0ludmFsaWQgbWVkaWEgcXVlcnknKTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3RJbmRleCArIDEgPT09IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lZGlhUHJlZml4OiBtZWRpYVByZWZpeCxcbiAgICAgICAgbWVkaWFUeXBlOiBtZWRpYVR5cGUsXG4gICAgICAgIG1lZGlhQ29uZGl0aW9uOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZmlyc3RJbmRleCArIDQgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICB2YXIgc2Vjb25kTm9uVW5hcnlUb2tlbiA9IHRva2Vuc1tmaXJzdEluZGV4ICsgMV07XG5cbiAgICAgIGlmIChzZWNvbmROb25VbmFyeVRva2VuLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiBzZWNvbmROb25VbmFyeVRva2VuLnZhbHVlID09PSAnYW5kJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZWRpYVByZWZpeDogbWVkaWFQcmVmaXgsXG4gICAgICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSxcbiAgICAgICAgICAgIG1lZGlhQ29uZGl0aW9uOiB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2Vucy5zbGljZShmaXJzdEluZGV4ICsgMiksIGZhbHNlKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIGFmdGVyICdhbmQnXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiRXhwZWN0ZWQgJ2FuZCcgYWZ0ZXIgbWVkaWEgcHJlZml4XCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcignRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIGFmdGVyIG1lZGlhIHByZWZpeCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvcignRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIG9yIG1lZGlhIHByZWZpeCcpO1xuICB9XG59O1xudmFyIHRva2VuaXplTWVkaWFDb25kaXRpb24gPSBmdW5jdGlvbiB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2VucywgbWF5Q29udGFpbk9yLCBwcmV2aW91c09wZXJhdG9yKSB7XG4gIGlmIChwcmV2aW91c09wZXJhdG9yID09PSB2b2lkIDApIHtcbiAgICBwcmV2aW91c09wZXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0b2tlbnMubGVuZ3RoIDwgMyB8fCB0b2tlbnNbMF0udHlwZSAhPT0gJzwoLXRva2VuPicgfHwgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSAnPCktdG9rZW4+Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZWRpYSBjb25kaXRpb24nKTtcbiAgfVxuXG4gIHZhciBlbmRJbmRleE9mRmlyc3RGZWF0dXJlID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gIHZhciBtYXhEZXB0aCA9IDA7XG4gIHZhciBjb3VudCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJzwoLXRva2VuPicpIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBjb3VudCk7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSAnPCktdG9rZW4+Jykge1xuICAgICAgY291bnQgLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgIGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGVkIHBhcmVuc1xcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uJyk7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBmZWF0dXJlVG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgKyAxKTtcblxuICBpZiAobWF4RGVwdGggPT09IDEpIHtcbiAgICBjaGlsZCA9IHRva2VuaXplTWVkaWFGZWF0dXJlKGZlYXR1cmVUb2tlbnMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChmZWF0dXJlVG9rZW5zWzFdLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiBmZWF0dXJlVG9rZW5zWzFdLnZhbHVlID09PSAnbm90Jykge1xuICAgICAgY2hpbGQgPSB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKGZlYXR1cmVUb2tlbnMuc2xpY2UoMiwgLTEpLCB0cnVlLCAnbm90Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gdG9rZW5pemVNZWRpYUNvbmRpdGlvbihmZWF0dXJlVG9rZW5zLnNsaWNlKDEsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgPT09IHRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZXJhdG9yOiBwcmV2aW91c09wZXJhdG9yLFxuICAgICAgY2hpbGRyZW46IFtjaGlsZF1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0VG9rZW4gPSB0b2tlbnNbZW5kSW5kZXhPZkZpcnN0RmVhdHVyZSArIDFdO1xuXG4gICAgaWYgKG5leHRUb2tlbi50eXBlICE9PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcGVyYXRvclxcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uJyk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c09wZXJhdG9yICE9PSBudWxsICYmIHByZXZpb3VzT3BlcmF0b3IgIT09IG5leHRUb2tlbi52YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ1wiLmNvbmNhdChuZXh0VG9rZW4udmFsdWUsIFwiJyBhbmQgJ1wiKS5jb25jYXQocHJldmlvdXNPcGVyYXRvciwgXCInIG11c3Qgbm90IGJlIGF0IHNhbWUgbGV2ZWxcXG5JbnZhbGlkIG1lZGlhIGNvbmRpdGlvblwiKSk7XG4gICAgfSBlbHNlIGlmIChuZXh0VG9rZW4udmFsdWUgPT09ICdvcicgJiYgIW1heUNvbnRhaW5Pcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSAnb3InIGF0IHRvcCBsZXZlbCBvZiBhIG1lZGlhIHF1ZXJ5XFxuSW52YWxpZCBtZWRpYSBjb25kaXRpb25cIik7XG4gICAgfSBlbHNlIGlmIChuZXh0VG9rZW4udmFsdWUgIT09ICdhbmQnICYmIG5leHRUb2tlbi52YWx1ZSAhPT0gJ29yJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGVyYXRvcjogJ1wiLmNvbmNhdChuZXh0VG9rZW4udmFsdWUsIFwiJ1xcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgc2libGluZ3MgPSB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2Vucy5zbGljZShlbmRJbmRleE9mRmlyc3RGZWF0dXJlICsgMiksIG1heUNvbnRhaW5PciwgbmV4dFRva2VuLnZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlcmF0b3I6IG5leHRUb2tlbi52YWx1ZSxcbiAgICAgIGNoaWxkcmVuOiBbY2hpbGRdLmNvbmNhdChzaWJsaW5ncy5jaGlsZHJlbilcbiAgICB9O1xuICB9XG59O1xudmFyIHRva2VuaXplTWVkaWFGZWF0dXJlID0gZnVuY3Rpb24gdG9rZW5pemVNZWRpYUZlYXR1cmUocmF3VG9rZW5zKSB7XG4gIGlmIChyYXdUb2tlbnMubGVuZ3RoIDwgMyB8fCByYXdUb2tlbnNbMF0udHlwZSAhPT0gJzwoLXRva2VuPicgfHwgcmF3VG9rZW5zW3Jhd1Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSAnPCktdG9rZW4+Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZWRpYSBmZWF0dXJlJyk7XG4gIH1cblxuICB2YXIgdG9rZW5zID0gW3Jhd1Rva2Vuc1swXV07XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCByYXdUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA8IHJhd1Rva2Vucy5sZW5ndGggLSAyKSB7XG4gICAgICB2YXIgYSA9IHJhd1Rva2Vuc1tpXTtcbiAgICAgIHZhciBiID0gcmF3VG9rZW5zW2kgKyAxXTtcbiAgICAgIHZhciBjID0gcmF3VG9rZW5zW2kgKyAyXTtcblxuICAgICAgaWYgKGEudHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyAmJiBhLnZhbHVlID4gMCAmJiBiLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiBiLnZhbHVlID09PSAweDAwMmYgJiYgYy50eXBlID09PSAnPG51bWJlci10b2tlbj4nICYmIGMudmFsdWUgPiAwKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnPHJhdGlvLXRva2VuPicsXG4gICAgICAgICAgbnVtZXJhdG9yOiBhLnZhbHVlLFxuICAgICAgICAgIGRlbm9taW5hdG9yOiBjLnZhbHVlLFxuICAgICAgICAgIHdzQmVmb3JlOiBhLndzQmVmb3JlLFxuICAgICAgICAgIHdzQWZ0ZXI6IGMud3NBZnRlclxuICAgICAgICB9KTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChyYXdUb2tlbnNbaV0pO1xuICB9XG5cbiAgdmFyIG5leHRUb2tlbiA9IHRva2Vuc1sxXTtcblxuICBpZiAobmV4dFRva2VuLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiB0b2tlbnMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQ6ICdib29sZWFuJyxcbiAgICAgIGZlYXR1cmU6IG5leHRUb2tlbi52YWx1ZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodG9rZW5zLmxlbmd0aCA9PT0gNSAmJiB0b2tlbnNbMV0udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nICYmIHRva2Vuc1syXS50eXBlID09PSAnPGNvbG9uLXRva2VuPicpIHtcbiAgICB2YXIgdmFsdWVUb2tlbiA9IHRva2Vuc1szXTtcblxuICAgIGlmICh2YWx1ZVRva2VuLnR5cGUgPT09ICc8bnVtYmVyLXRva2VuPicgfHwgdmFsdWVUb2tlbi50eXBlID09PSAnPGRpbWVuc2lvbi10b2tlbj4nIHx8IHZhbHVlVG9rZW4udHlwZSA9PT0gJzxyYXRpby10b2tlbj4nIHx8IHZhbHVlVG9rZW4udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICB2YXIgZmVhdHVyZSA9IHRva2Vuc1sxXS52YWx1ZTtcbiAgICAgIHZhciBwcmVmaXggPSBudWxsO1xuICAgICAgdmFyIHNsaWNlID0gZmVhdHVyZS5zbGljZSgwLCA0KTtcblxuICAgICAgaWYgKHNsaWNlID09PSAnbWluLScpIHtcbiAgICAgICAgcHJlZml4ID0gJ21pbic7XG4gICAgICAgIGZlYXR1cmUgPSBmZWF0dXJlLnNsaWNlKDQpO1xuICAgICAgfSBlbHNlIGlmIChzbGljZSA9PT0gJ21heC0nKSB7XG4gICAgICAgIHByZWZpeCA9ICdtYXgnO1xuICAgICAgICBmZWF0dXJlID0gZmVhdHVyZS5zbGljZSg0KTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVUb2tlbi53c0JlZm9yZTtcbiAgICAgICAgICB2YWx1ZVRva2VuLndzQWZ0ZXI7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX19yZXN0KHZhbHVlVG9rZW4sIFtcIndzQmVmb3JlXCIsIFwid3NBZnRlclwiXSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6ICd2YWx1ZScsXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHRva2Vucy5sZW5ndGggPj0gNSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0b2tlbml6ZVJhbmdlKHRva2Vucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiAncmFuZ2UnLFxuICAgICAgICBmZWF0dXJlOiByYW5nZS5mZWF0dXJlTmFtZSxcbiAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0ludmFsaWQgbWVkaWEgZmVhdHVyZScsIGVycik7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lZGlhIGZlYXR1cmUnKTtcbn07XG52YXIgdG9rZW5pemVSYW5nZSA9IGZ1bmN0aW9uIHRva2VuaXplUmFuZ2UodG9rZW5zKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcblxuICBpZiAodG9rZW5zLmxlbmd0aCA8IDUgfHwgdG9rZW5zWzBdLnR5cGUgIT09ICc8KC10b2tlbj4nIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gJzwpLXRva2VuPicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgfVxuXG4gIHZhciByYW5nZSA9IHtcbiAgICBsZWZ0VG9rZW46IG51bGwsXG4gICAgbGVmdE9wOiBudWxsLFxuICAgIGZlYXR1cmVOYW1lOiAnJyxcbiAgICByaWdodE9wOiBudWxsLFxuICAgIHJpZ2h0VG9rZW46IG51bGxcbiAgfTtcbiAgdmFyIGhhc0xlZnQgPSB0b2tlbnNbMV0udHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyB8fCB0b2tlbnNbMV0udHlwZSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+JyB8fCB0b2tlbnNbMV0udHlwZSA9PT0gJzxyYXRpby10b2tlbj4nIHx8IHRva2Vuc1sxXS50eXBlID09PSAnPGlkZW50LXRva2VuPicgJiYgdG9rZW5zWzFdLnZhbHVlID09PSAnaW5maW5pdGUnO1xuXG4gIGlmICh0b2tlbnNbMl0udHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nKSB7XG4gICAgaWYgKHRva2Vuc1syXS52YWx1ZSA9PT0gMHgwMDNjKSB7XG4gICAgICBpZiAodG9rZW5zWzNdLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiB0b2tlbnNbM10udmFsdWUgPT09IDB4MDAzZCAmJiAhdG9rZW5zWzNdLndzQmVmb3JlKSB7XG4gICAgICAgIHJhbmdlW2hhc0xlZnQgPyAnbGVmdE9wJyA6ICdyaWdodE9wJ10gPSAnPD0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2VbaGFzTGVmdCA/ICdsZWZ0T3AnIDogJ3JpZ2h0T3AnXSA9ICc8JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2Vuc1syXS52YWx1ZSA9PT0gMHgwMDNlKSB7XG4gICAgICBpZiAodG9rZW5zWzNdLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiB0b2tlbnNbM10udmFsdWUgPT09IDB4MDAzZCAmJiAhdG9rZW5zWzNdLndzQmVmb3JlKSB7XG4gICAgICAgIHJhbmdlW2hhc0xlZnQgPyAnbGVmdE9wJyA6ICdyaWdodE9wJ10gPSAnPj0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2VbaGFzTGVmdCA/ICdsZWZ0T3AnIDogJ3JpZ2h0T3AnXSA9ICc+JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2Vuc1syXS52YWx1ZSA9PT0gMHgwMDNkKSB7XG4gICAgICByYW5nZVtoYXNMZWZ0ID8gJ2xlZnRPcCcgOiAncmlnaHRPcCddID0gJz0nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzTGVmdCkge1xuICAgICAgcmFuZ2UubGVmdFRva2VuID0gdG9rZW5zWzFdO1xuICAgIH0gZWxzZSBpZiAodG9rZW5zWzFdLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgcmFuZ2UuZmVhdHVyZU5hbWUgPSB0b2tlbnNbMV0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wID0gMiArICgoX2IgPSAoX2EgPSByYW5nZVtoYXNMZWZ0ID8gJ2xlZnRPcCcgOiAncmlnaHRPcCddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICB2YXIgdG9rZW5BZnRlckZpcnN0T3AgPSB0b2tlbnNbdG9rZW5JbmRleEFmdGVyRmlyc3RPcF07XG5cbiAgICBpZiAoaGFzTGVmdCkge1xuICAgICAgaWYgKHRva2VuQWZ0ZXJGaXJzdE9wLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgICByYW5nZS5mZWF0dXJlTmFtZSA9IHRva2VuQWZ0ZXJGaXJzdE9wLnZhbHVlO1xuXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID49IDcpIHtcbiAgICAgICAgICB2YXIgc2Vjb25kT3BUb2tlbiA9IHRva2Vuc1t0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wICsgMV07XG4gICAgICAgICAgdmFyIGZvbGxvd2luZ1Rva2VuID0gdG9rZW5zW3Rva2VuSW5kZXhBZnRlckZpcnN0T3AgKyAyXTtcblxuICAgICAgICAgIGlmIChzZWNvbmRPcFRva2VuLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+Jykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gc2Vjb25kT3BUb2tlbi52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSAweDAwM2MpIHtcbiAgICAgICAgICAgICAgaWYgKGZvbGxvd2luZ1Rva2VuLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiBmb2xsb3dpbmdUb2tlbi52YWx1ZSA9PT0gMHgwMDNkICYmICFmb2xsb3dpbmdUb2tlbi53c0JlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnJpZ2h0T3AgPSAnPD0nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlLnJpZ2h0T3AgPSAnPCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT09IDB4MDAzZSkge1xuICAgICAgICAgICAgICBpZiAoZm9sbG93aW5nVG9rZW4udHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nICYmIGZvbGxvd2luZ1Rva2VuLnZhbHVlID09PSAweDAwM2QgJiYgIWZvbGxvd2luZ1Rva2VuLndzQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UucmlnaHRPcCA9ICc+PSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UucmlnaHRPcCA9ICc+JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b2tlbkFmdGVyU2Vjb25kT3AgPSB0b2tlbnNbdG9rZW5JbmRleEFmdGVyRmlyc3RPcCArIDEgKyAoKF9kID0gKF9jID0gcmFuZ2UucmlnaHRPcCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCldO1xuICAgICAgICAgICAgcmFuZ2UucmlnaHRUb2tlbiA9IHRva2VuQWZ0ZXJTZWNvbmRPcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRva2VuSW5kZXhBZnRlckZpcnN0T3AgKyAyICE9PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5yaWdodFRva2VuID0gdG9rZW5BZnRlckZpcnN0T3A7XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkUmFuZ2UgPSBudWxsO1xuICAgIHZhciBsdCA9IHJhbmdlLmxlZnRUb2tlbixcbiAgICAgICAgbGVmdE9wID0gcmFuZ2UubGVmdE9wLFxuICAgICAgICBmZWF0dXJlTmFtZSA9IHJhbmdlLmZlYXR1cmVOYW1lLFxuICAgICAgICByaWdodE9wID0gcmFuZ2UucmlnaHRPcCxcbiAgICAgICAgcnQgPSByYW5nZS5yaWdodFRva2VuO1xuICAgIHZhciBsZWZ0VG9rZW4gPSBudWxsO1xuXG4gICAgaWYgKGx0ICE9PSBudWxsKSB7XG4gICAgICBpZiAobHQudHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICAgIHZhciB0eXBlID0gbHQudHlwZSxcbiAgICAgICAgICAgIHZhbHVlID0gbHQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnaW5maW5pdGUnKSB7XG4gICAgICAgICAgbGVmdFRva2VuID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobHQudHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyB8fCBsdC50eXBlID09PSAnPGRpbWVuc2lvbi10b2tlbj4nIHx8IGx0LnR5cGUgPT09ICc8cmF0aW8tdG9rZW4+Jykge1xuICAgICAgICBsdC53c0JlZm9yZTtcbiAgICAgICAgICAgIGx0LndzQWZ0ZXI7XG4gICAgICAgICAgICB2YXIgbHROb1dTID0gX19yZXN0KGx0LCBbXCJ3c0JlZm9yZVwiLCBcIndzQWZ0ZXJcIl0pO1xuXG4gICAgICAgIGxlZnRUb2tlbiA9IGx0Tm9XUztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmlnaHRUb2tlbiA9IG51bGw7XG5cbiAgICBpZiAocnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChydC50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBydC50eXBlLFxuICAgICAgICAgICAgdmFsdWUgPSBydC52YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgPT09ICdpbmZpbml0ZScpIHtcbiAgICAgICAgICByaWdodFRva2VuID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnQudHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyB8fCBydC50eXBlID09PSAnPGRpbWVuc2lvbi10b2tlbj4nIHx8IHJ0LnR5cGUgPT09ICc8cmF0aW8tdG9rZW4+Jykge1xuICAgICAgICBydC53c0JlZm9yZTtcbiAgICAgICAgICAgIHJ0LndzQWZ0ZXI7XG4gICAgICAgICAgICB2YXIgcnROb1dTID0gX19yZXN0KHJ0LCBbXCJ3c0JlZm9yZVwiLCBcIndzQWZ0ZXJcIl0pO1xuXG4gICAgICAgIHJpZ2h0VG9rZW4gPSBydE5vV1M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxlZnRUb2tlbiAhPT0gbnVsbCAmJiByaWdodFRva2VuICE9PSBudWxsKSB7XG4gICAgICBpZiAoKGxlZnRPcCA9PT0gJzwnIHx8IGxlZnRPcCA9PT0gJzw9JykgJiYgKHJpZ2h0T3AgPT09ICc8JyB8fCByaWdodE9wID09PSAnPD0nKSkge1xuICAgICAgICB2YWxpZFJhbmdlID0ge1xuICAgICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICAgIGxlZnRPcDogbGVmdE9wLFxuICAgICAgICAgIGZlYXR1cmVOYW1lOiBmZWF0dXJlTmFtZSxcbiAgICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICAgIHJpZ2h0VG9rZW46IHJpZ2h0VG9rZW5cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKGxlZnRPcCA9PT0gJz4nIHx8IGxlZnRPcCA9PT0gJz49JykgJiYgKHJpZ2h0T3AgPT09ICc+JyB8fCByaWdodE9wID09PSAnPj0nKSkge1xuICAgICAgICB2YWxpZFJhbmdlID0ge1xuICAgICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICAgIGxlZnRPcDogbGVmdE9wLFxuICAgICAgICAgIGZlYXR1cmVOYW1lOiBmZWF0dXJlTmFtZSxcbiAgICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICAgIHJpZ2h0VG9rZW46IHJpZ2h0VG9rZW5cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVmdFRva2VuID09PSBudWxsICYmIGxlZnRPcCA9PT0gbnVsbCAmJiByaWdodE9wICE9PSBudWxsICYmIHJpZ2h0VG9rZW4gIT09IG51bGwpIHtcbiAgICAgIHZhbGlkUmFuZ2UgPSB7XG4gICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICBsZWZ0T3A6IGxlZnRPcCxcbiAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lLFxuICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICByaWdodFRva2VuOiByaWdodFRva2VuXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVmdFRva2VuICE9PSBudWxsICYmIGxlZnRPcCAhPT0gbnVsbCAmJiByaWdodE9wID09PSBudWxsICYmIHJpZ2h0VG9rZW4gPT09IG51bGwpIHtcbiAgICAgIHZhbGlkUmFuZ2UgPSB7XG4gICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICBsZWZ0T3A6IGxlZnRPcCxcbiAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lLFxuICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICByaWdodFRva2VuOiByaWdodFRva2VuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZFJhbmdlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICB9XG59O1xuXG5leHBvcnQgeyBjb25zdW1lRXNjYXBlLCBjb25zdW1lSWRlbnQsIGNvbnN1bWVJZGVudExpa2UsIGNvbnN1bWVJZGVudFVuc2FmZSwgY29uc3VtZU51bWJlciwgY29uc3VtZU51bWVyaWMsIGNvbnN1bWVTdHJpbmcsIGNvbnN1bWVVcmwsIGxleGljYWxBbmFseXNpcywgcmVtb3ZlV2hpdGVzcGFjZSwgc3ludGFjdGljQW5hbHlzaXMsIHRvQVNULCB0b1VuZmxhdHRlbmVkQVNULCB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uLCB0b2tlbml6ZU1lZGlhRmVhdHVyZSwgdG9rZW5pemVNZWRpYVF1ZXJ5LCB0b2tlbml6ZVJhbmdlLCB3b3VsZFN0YXJ0SWRlbnRpZmllciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWEtcXVlcnktcGFyc2VyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/media-query-parser/dist/media-query-parser.esm.js\n");

/***/ })

};
;